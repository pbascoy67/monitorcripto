<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Monitor Criptomonedas - RSI + PnL + Voz + Favoritas Primero + Comparación</title>
  <style>
    /* === Estilos Generales === */
    body.dark {
      background-color: #0a0e17;
      color: #ffffff;
    }
    body.light {
      background-color: #f0f0f0;
      color: #000000;
    }
    body {
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 20px;
      transition: background-color 0.3s, color 0.3s;
    }
    h1 {
      text-align: center;
      color: #00ffcc;
      font-size: 2.5em;
      margin-bottom: 5px;
    }
    h3 {
      text-align: center;
      color: #7a8599;
      margin-top: -10px;
      font-size: 0.9em;
      font-weight: normal;
    }
    #indicatorExplanation {
      max-width: 800px;
      margin: 10px auto 20px auto;
      background-color: #1a2332;
      border-radius: 10px;
      padding: 15px;
      color: #ccc;
      font-size: 0.9em;
    }
    body.light #indicatorExplanation {
      background-color: #eaeaea;
      color: #333;
    }
    #indicatorExplanation p {
      margin: 5px 0;
      line-height: 1.3em;
    }
    #lastUpdate {
      text-align: center;
      margin-top: 5px;
      font-style: italic;
      color: #7a8599;
      margin-bottom: 20px;
    }
    /* === Contenedores de Filtros y Botones === */
    .top-bar {
      display: flex;
      justify-content: space-between; /* Cambiado para acomodar nuevos botones */
      align-items: center;
      margin-bottom: 20px;
      gap: 10px;
      flex-wrap: wrap; /* Permitir que los elementos se ajusten en pantallas pequeñas */
    }
    #favoritesBar {
      display: flex;
      gap: 5px;
    }
    #filtersContainer {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 0 auto 20px auto; /* Centrado horizontal */
      padding: 10px 20px;
      background-color: #1a2332;
      border-radius: 10px;
      width: fit-content;
      flex-wrap: wrap; /* Permitir que los elementos se ajusten en pantallas pequeñas */
    }
    body.light #filtersContainer {
      background-color: #eaeaea;
    }
    #filtersContainer select {
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
      min-width: 150px;
      cursor: pointer;
    }
    body.light #filtersContainer select {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    #filtersContainer option {
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
    }
    body.light #filtersContainer option {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    /* === Estilos de Botones === */
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      font-size: 1em;
      cursor: pointer;
      transition: background-color 0.3s, opacity 0.3s;
      margin: 5px;
      color: #ffffff;
      display: inline-block;
      text-align: center;
      text-decoration: none;
    }
    .btn-primary {
      background-color: #00ffcc;
      color: #000000; /* Cambiado a negro para mejor legibilidad */
    }
    .btn-primary:hover {
      background-color: #00e6b8;
    }
    .btn-secondary {
      background-color: #FF9800;
    }
    .btn-secondary:hover {
      background-color: #e68900;
    }
    .btn-danger {
      background-color: #F44336;
    }
    .btn-danger:hover {
      background-color: #e31e26;
    }
    .btn-success {
      background-color: #4CAF50;
    }
    .btn-success:hover {
      background-color: #45a049;
    }
    .btn-warning {
      background-color: #FFEB3B;
      color: #000000;
    }
    .btn-warning:hover {
      background-color: #FDD835;
    }
    .btn-info {
      background-color: #2196F3;
    }
    .btn-info:hover {
      background-color: #1976D2;
    }
    .btn-default {
      background-color: #9E9E9E;
      color: #ffffff;
    }
    .btn-default:hover {
      background-color: #757575;
    }
    .btn.disabled,
    .btn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }
    /* === Botón de Comparación en la Página Principal === */
    #compareCryptoBtn {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
    }
    /* === Grilla de Criptomonedas === */
    #cryptoGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }
    .crypto-card {
      background-color: #1a2332;
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
      cursor: pointer;
      position: relative;
    }
    body.light .crypto-card {
      background-color: #ffffff;
      color: #000000;
    }
    .crypto-card:hover {
      transform: translateY(-5px);
    }
    .crypto-card:hover::after {
      content: "Clic para ver gráfico";
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #00ffcc;
      color: #0a0e17;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      white-space: nowrap;
    }
    .crypto-logo {
      width: 60px;
      height: 60px;
      margin-bottom: 15px;
    }
    .crypto-name {
      font-size: 1.2em;
      font-weight: bold;
      margin-bottom: 10px;
      word-break: break-word;
    }
    .crypto-price {
      font-size: 1.1em;
      margin-bottom: 15px;
    }
    .flag {
      display: inline-block;
      padding: 8px 15px;
      border-radius: 20px;
      font-weight: bold;
      text-transform: uppercase;
      font-size: 0.9em;
      white-space: nowrap;
    }
    .green-flag {
      background-color: #4CAF50;
      color: white;
    }
    .red-flag {
      background-color: #F44336;
      color: white;
    }
    .neutral-flag {
      background-color: #FF9800;
      color: white;
    }
    .mini-chart-container {
      margin-top: 15px;
      position: relative;
      height: 80px;
    }
    canvas.mini-chart {
      width: 100%;
      height: 100%;
    }
    .no-chart-text {
      margin-top: 15px;
      font-size: 0.8em;
      color: #7a8599;
    }
    .favorite-icon {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: 1.2em;
      color: #ffc107;
    }
    
    /* === Modal Detallado === */
    #modalOverlay,
    #compareModalOverlay,
    #portfolioModalOverlay { /* Nuevo modal */
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      padding: 0;
      overflow: hidden;
    }
    #modalContent,
    #compareModalContent,
    #portfolioModalContent { /* Nuevo modal */
      background: #1a2332;
      border-radius: 15px;
      width: 95vw;
      height: 95vh;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding: 20px;
      transition: width 0.3s, height 0.3s;
    }
    body.light #modalContent,
    body.light #compareModalContent,
    body.light #portfolioModalContent { /* Nuevo modal */
      background-color: #ffffff;
      color: #000000;
    }
    .modalCloseBtn {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 5000;
    }
    #chartContainer,
    #comparisonChartContainer,
    #portfolioChartContainer { /* Nuevo modal */
      width: 100%;
      min-height: 300px;
      margin-bottom: 20px;
      position: relative;
      transition: width 0.3s, height 0.3s; 
    }
    /* Clase expandida para móviles */
    #modalOverlay.expanded-view #modalContent,
    #compareModalOverlay.expanded-view #compareModalContent,
    #portfolioModalOverlay.expanded-view #portfolioModalContent { /* Nuevo modal */
      width: 100vw;
      height: 100vh;
      border-radius: 0;
      flex-direction: column;
      padding: 0;
    }
    
    #modalOverlay.expanded-view #chartContainer,
    #compareModalOverlay.expanded-view #comparisonChartContainer,
    #portfolioModalOverlay.expanded-view #portfolioChartContainer { /* Nuevo modal */
      width: 100%;
      height: calc(100vh - 50px); /* Ajustar según los elementos del modal */
      flex-grow: 1;
    }
    
    /* Asegurar que el canvas del gráfico ocupe todo el contenedor */
    #cryptoChart,
    #comparisonChart,
    #portfolioChart { /* Nuevo modal */
      width: 100% !important;
      height: 100% !important;
    }
    
    /* Ocultar otros elementos del modal cuando está en vista expandida */
    #modalOverlay.expanded-view #modalContent > *:not(#chartContainer):not(#volverBtn),
    #compareModalOverlay.expanded-view #compareModalContent > *:not(#comparisonChartContainer):not(#volverCompareBtn),
    #portfolioModalOverlay.expanded-view #portfolioModalContent > *:not(#portfolioChartContainer):not(#volverPortfolioBtn) { /* Nuevo modal */
      display: none;
    }
    
    /* Estilos del botón "Regresar" */
    #volverBtn,
    #volverCompareBtn,
    #volverPortfolioBtn { /* Nuevo modal */
      /* Heredan estilos de .btn */
      /* Ya tienen clases específicas asignadas en HTML */
      display: none; /* Inicialmente oculto */
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 5000;
    }
    
    /* === Modal de Comparación === */
    #compareModalContent select {
      background-color: #000000;
      color: #ffffff;
    }
    body.light #compareModalContent select {
      background-color: #ffffff;
      color: #000000;
    }
    
    /* === Tabla Comparativa y Portafolio === */
    #comparisonTable,
    #portfolioTable { /* Nuevo modal */
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      overflow-x: auto;
    }
    #comparisonTable th, #comparisonTable td,
    #portfolioTable th, #portfolioTable td { /* Nuevo modal */
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
      position: relative; /* Para el tooltip */
      cursor: default;
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
    }
    body.light #comparisonTable th,
    body.light #comparisonTable td,
    body.light #portfolioTable th,
    body.light #portfolioTable td { /* Nuevo modal */
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    #comparisonTable th,
    #portfolioTable th { /* Nuevo modal */
      background-color: #f2f2f2;
      font-weight: bold;
      color: #000000; /* Cambiado a negro */
    }
    #comparisonTable tr:hover,
    #portfolioTable tr:hover { /* Nuevo modal */
      background-color: #f5f5f5;
    }
    /* Tooltip Styles */
    .tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s;
      z-index: 100;
      font-size: 0.8em;
    }
    #comparisonTable th:hover .tooltip,
    #comparisonTable td:hover .tooltip,
    #portfolioTable th:hover .tooltip,
    #portfolioTable td:hover .tooltip { /* Nuevo modal */
      opacity: 1;
      visibility: visible;
    }
    
    /* === Botones y Otros === */
    #themeToggle {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 2000;
    }
    #favoritesBar {
      display: flex;
      gap: 5px;
    }
    #btnFavoritos, #btnVerTodos, #btnPortfolio { /* Nuevo modal */
      /* Heredan estilos de .btn */
      /* Ya tienen clases específicas asignadas en HTML */
    }
    #updateChartBtn {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
      margin: 10px auto 5px auto;
      display: block;
      font-size: 0.9em;
    }
    #lastUpdateModal {
      text-align: center;
      font-style: italic;
      color: #7a8599;
      margin-top: 5px;
      margin-bottom: 10px;
    }
    #verAnalisisBtn {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
      margin: 10px auto 0 auto;
      display: block;
      font-size: 0.9em;
    }
    #silenciarAlertasBtn {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 2100;
    }
    
    /* === Barra de Progreso === */
    #progressOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 4000;
      flex-direction: column;
      color: #ffffff;
      font-size: 1.2em;
      flex-wrap: wrap;
    }
    #progressBarContainer {
      width: 80%;
      background-color: #ddd;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 20px;
    }
    #progressBar {
      width: 0%;
      height: 30px;
      background-color: #00ffcc;
      transition: width 0.3s;
    }
    @media (max-width: 768px) {
      #modalContent,
      #compareModalContent,
      #portfolioModalContent { /* Nuevo modal */
        width: 98vw;
        height: 98vh;
      }
      #progressBarContainer {
        width: 90%;
      }
      /* Ya movimos .expanded-chart fuera de la media query */
      /* Ajustes adicionales para mejorar la visualización en móviles */
      #filtersContainer {
        flex-direction: column;
        align-items: stretch;
      }
      #addPortfolioForm {
        flex-direction: column;
      }
      #addPortfolioForm .form-group {
        margin-bottom: 10px;
      }
      #portfolioModalContent form {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }
      #addPortfolioForm select,
      #addPortfolioForm input {
        flex: 1 1 45%; /* Dos columnas */
      }
    }
    
    /* === Nuevos Estilos para Vista Expandida en el Modal === */
    /* Ya definidos arriba */
    
    /* === Nuevos Estilos para el Selector de Marco Temporal en el Modal === */
    #modalTimeFrameContainer {
      text-align: center;
      margin-bottom: 20px;
    }
    #modalTimeFrameContainer label {
      margin-right: 5px;
      font-weight: bold;
      cursor: help; /* Indica que hay información adicional */
    }
    #modalTimeFrameFilter {
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
      min-width: 150px;
      cursor: pointer;
    }
    body.light #modalTimeFrameFilter {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    #modalTimeFrameFilter option {
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
    }
    body.light #modalTimeFrameFilter option {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    
    /* === Responsive Grids and Charts === */
    /* Asegurar que el gráfico y la tabla sean responsivos */
    @media (max-width: 768px) {
      #comparisonChartContainer, #chartContainer, #portfolioChartContainer { /* Nuevo modal */
        height: 300px;
      }
      #cryptoChart, #comparisonChart, #portfolioChart { /* Nuevo modal */
        height: 100% !important;
      }
    }
    
    /* === Estilos para Recomendaciones en Comparación === */
    #comparisonRecommendation {
      text-align: center;
      margin-top: 20px;
      font-size: 1.1em;
      font-weight: bold;
    }
    .green-recommendation {
      color: #4CAF50;
    }
    .red-recommendation {
      color: #F44336;
    }
    .orange-recommendation {
      color: #FF9800;
    }
    
    /* === Modal de Portafolio === */
    #portfolioModalContent {
      /* Reutilizar estilos existentes */
    }
    #portfolioModalContent h1 {
      color: #00ffcc;
      text-align: center;
      margin-bottom: 20px;
    }
    #portfolioTable th {
      color: #000000; /* Letras en negro para legibilidad */
    }
    #portfolioTable td {
      color: #ffffff; /* Letras blancas */
      background-color: #000000; /* Fondo negro */
    }
    body.light #portfolioTable td {
      color: #000000; /* Letras negras en modo claro */
      background-color: #ffffff; /* Fondo blanco en modo claro */
    }
    #addPortfolioForm select,
    #addPortfolioForm input {
      width: 100%;
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
      cursor: pointer;
    }
    body.light #addPortfolioForm select,
    body.light #addPortfolioForm input {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    #addPortfolioForm option {
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
    }
    body.light #addPortfolioForm option {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    #portfolioSummary .summary-item {
      font-weight: bold;
    }
    #portfolioSummary .summary-value {
      color: #4CAF50;
    }
    /* Ajuste para permitir hasta 10 decimales en el campo cantidad */
    #portfolioCryptoAmount {
      step: 0.0000000001;
    }
    #portfolioCryptoBuyPrice {
      step: 0.0000000001;
    }
    
    /* === Selector de Intervalo de Actualización === */
    #updateIntervalContainer {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    #updateIntervalContainer label {
      font-weight: bold;
      cursor: help;
    }
    #updateInterval {
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
      min-width: 100px;
      cursor: pointer;
    }
    body.light #updateInterval {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    #updateInterval option {
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
    }
    body.light #updateInterval option {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    
    /* Ajustes para el formulario horizontal en el modal de portafolio */
    #addPortfolioForm {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: space-between;
    }
    #addPortfolioForm .form-group {
      display: flex;
      flex-direction: column;
      flex: 1 1 45%; /* Dos columnas */
    }
    #addPortfolioForm label {
      margin-bottom: 5px;
      font-weight: bold;
    }
    #addPortfolioForm button {
      flex: 1 1 100%;
      margin-top: 10px;
    }
    
    /* === Responsive Ajustes para Modales en Móviles === */
    @media (max-width: 768px) {
      /* Asegurar que los modales ocupen toda la pantalla */
      #modalOverlay.expanded-view #modalContent,
      #compareModalOverlay.expanded-view #compareModalContent,
      #portfolioModalOverlay.expanded-view #portfolioModalContent {
        width: 100vw;
        height: 100vh;
      }
      
      /* Ajustes específicos para mejorar la usabilidad en móviles */
      .crypto-card {
        padding: 15px;
      }
      .crypto-logo {
        width: 50px;
        height: 50px;
      }
      .crypto-name {
        font-size: 1em;
      }
      .crypto-price {
        font-size: 1em;
      }
      .flag {
        padding: 6px 12px;
        font-size: 0.8em;
      }
      #filtersContainer select,
      #modalTimeFrameFilter,
      #updateInterval {
        min-width: 100%;
      }
      #addPortfolioForm {
        flex-direction: column;
      }
      #addPortfolioForm .form-group {
        flex: 1 1 100%;
      }
    }
    
    /* === Estilos para Recomendaciones en Comparación === */
    #comparisonRecommendation {
      text-align: center;
      margin-top: 20px;
      font-size: 1.1em;
      font-weight: bold;
    }
    .green-recommendation {
      color: #4CAF50;
    }
    .red-recommendation {
      color: #F44336;
    }
    .orange-recommendation {
      color: #FF9800;
    }
    
    /* === Modal de Portafolio === */
    #portfolioModalContent {
      /* Reutilizar estilos existentes */
    }
    #portfolioModalContent h1 {
      color: #00ffcc;
      text-align: center;
      margin-bottom: 20px;
    }
    #portfolioTable th {
      color: #000000; /* Letras en negro para legibilidad */
    }
    #portfolioTable td {
      color: #ffffff; /* Letras blancas */
      background-color: #000000; /* Fondo negro */
    }
    body.light #portfolioTable td {
      color: #000000; /* Letras negras en modo claro */
      background-color: #ffffff; /* Fondo blanco en modo claro */
    }
    #addPortfolioForm select,
    #addPortfolioForm input {
      width: 100%;
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
      cursor: pointer;
    }
    body.light #addPortfolioForm select,
    body.light #addPortfolioForm input {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    #addPortfolioForm option {
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
    }
    body.light #addPortfolioForm option {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    #portfolioSummary .summary-item {
      font-weight: bold;
    }
    #portfolioSummary .summary-value {
      color: #4CAF50;
    }
    /* Ajuste para permitir hasta 10 decimales en el campo cantidad */
    #portfolioCryptoAmount {
      step: 0.0000000001;
    }
    #portfolioCryptoBuyPrice {
      step: 0.0000000001;
    }
    
    /* === Selector de Intervalo de Actualización === */
    #updateIntervalContainer {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    #updateIntervalContainer label {
      font-weight: bold;
      cursor: help;
    }
    #updateInterval {
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
      min-width: 100px;
      cursor: pointer;
    }
    body.light #updateInterval {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    #updateInterval option {
      background-color: #000000; /* Fondo negro */
      color: #ffffff; /* Letras blancas */
    }
    body.light #updateInterval option {
      background-color: #ffffff; /* Fondo blanco en modo claro */
      color: #000000; /* Letras negras en modo claro */
    }
    
    /* Ajustes para el formulario horizontal en el modal de portafolio */
    #addPortfolioForm {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: space-between;
    }
    #addPortfolioForm .form-group {
      display: flex;
      flex-direction: column;
      flex: 1 1 45%; /* Dos columnas */
    }
    #addPortfolioForm label {
      margin-bottom: 5px;
      font-weight: bold;
    }
    #addPortfolioForm button {
      flex: 1 1 100%;
      margin-top: 10px;
    }
    
  </style>
</head>
<body class="dark">
  <h1>Monitor Criptomonedas</h1>
  <h3>by Pablo Bascoy</h3>

  <!-- Barra de progreso -->
  <div id="progressOverlay">
    <div id="progressMessage">Cargando criptomonedas...</div>
    <div id="progressBarContainer">
      <div id="progressBar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>

  <!-- Barra Superior con Botones "Favoritos", "Ver Todos", "Mi Portafolio Cripto" y "Intervalo de Actualización" -->
  <div class="top-bar">
    <div id="favoritesBar">
      <button id="btnFavoritos" class="btn btn-success">Favoritos</button>
      <button id="btnVerTodos" class="btn btn-secondary">Ver Todos</button>
      <button id="btnPortfolio" class="btn btn-primary">Mi Portafolio Cripto</button> <!-- Nuevo botón -->
    </div>
    <div id="updateIntervalContainer">
      <label for="updateInterval" title="Selecciona el intervalo en segundos para actualizar automáticamente">Intervalo de Actualización (segundos)</label>
      <select id="updateInterval">
        <option value="10">10</option>
        <option value="30" selected>30</option>
        <option value="60">60</option>
        <option value="120">120</option>
      </select>
    </div>
  </div>

  <!-- Explicación de RSI -->
  <div id="indicatorExplanation">
    <p><strong>¿Qué es el RSI (Relative Strength Index)?</strong></p>
    <p>El RSI mide la fortaleza o debilidad de un activo según sus últimos movimientos de precio, entre 0 y 100.</p>
    <ul>
      <li>RSI &gt; 70: Señal de venta.</li>
      <li>RSI &lt; 30: Señal de compra.</li>
      <li>RSI 30-70: Fase neutra.</li>
    </ul>
    <p>Las criptomonedas marcadas como favoritas aparecerán primero cada vez que se actualice (automático o manual).  
    Puedes actualizar manualmente o cada cierto número de segundos. El % de ganancia/pérdida se recalcula según tu precio de compra.</p>
  </div>

  <p id="lastUpdate">Última actualización: (sin datos)</p>

  <!-- Contenedor de Filtros -->
  <div id="filtersContainer">
    <div id="coinFilterContainer">
      <label for="coinFilter" title="Filtra por criptomoneda específica">Criptomoneda</label>
      <select id="coinFilter">
          <option value="all">Todas</option>
      </select>
    </div>
    <div id="rsiFilterContainer">
      <label for="rsiFilter" title="Filtra por estado del RSI">Estado RSI</label>
      <select id="rsiFilter">
          <option value="all">Todas</option>
          <option value="comprar">Comprar</option>
          <option value="vender">Vender</option>
          <option value="esperar">Esperar</option>
          <option value="neutral">Neutral</option>
      </select>
    </div>
  </div>

  <!-- Botón "Comparar Criptomonedas" Centrado Debajo de los Filtros -->
  <div style="text-align: center; margin-bottom: 20px;">
    <button id="compareCryptoBtn" class="btn btn-secondary">Comparar Criptomonedas</button>
  </div>

  <!-- Grilla de Criptomonedas -->
  <div id="cryptoGrid"></div>

  <!-- Modal Detallado -->
  <div id="modalOverlay">
    <div id="modalContent">
      <button class="btn btn-danger modalCloseBtn">Cerrar</button>
      <h2 id="modalTitle"></h2>
      <!-- Botón Actualizar que ahora solo actualiza la cripto del modal -->
      <button id="updateChartBtn" class="btn btn-info">Actualizar</button>
      <!-- Selector de Marco Temporal en el Modal -->
      <div id="modalTimeFrameContainer">
        <label for="modalTimeFrameFilter" title="Selecciona el marco temporal para el gráfico">Marco Temporal</label>
        <select id="modalTimeFrameFilter">
            <option value="5m">5 Minutos</option>
            <option value="15m">15 Minutos</option>
            <option value="1h">1 Hora</option>
            <option value="1d">Por Día</option>
            <option value="1w">Por Semana</option>
            <option value="1M">Por Mes</option>
            <option value="6M">Últimos 6 Meses</option>
            <option value="1Y">Último Año</option>
        </select>
      </div>
      <p id="lastUpdateModal">Última actualización: (sin datos)</p>
      <div class="modal-info" id="modalInfo"></div>
      <div id="chartContainer">
        <canvas id="cryptoChart"></canvas>
      </div>
      <!-- Botón para expandir el gráfico en móvil -->
      <button id="verAnalisisBtn" class="btn btn-warning">Ver Análisis</button>
      <!-- Botón para volver desde la vista expandida -->
      <button id="volverBtn" class="btn btn-danger">Regresar</button>

      <div id="priceAlertContainer">
        <label id="percentAlertLabel" title="Establece el porcentaje de ganancia para recibir una alerta">% de ganancia para alerta:
          <input type="number" id="priceAlertInput" placeholder="5">
        </label>
        <button id="setAlertBtn" class="btn btn-success">Set Alert</button>
      </div>

      <div id="buyPriceContainer">
        <label title="Ingresa tu precio de compra">Precio de Compra: $<input type="number" id="buyPriceInput" placeholder="0.00" step="0.0000000001"></label> <!-- Ajuste del step -->
        <button id="setBuyPriceBtn" class="btn btn-primary">Colocar precio de compra</button>
        <button id="clearBuyPriceBtn" class="btn btn-danger">Borrar precio de compra</button>
      </div>
      <div id="profitLossContainer">
        <p id="profitLossText">Ganancia/Perdida: 0%</p>
      </div>

      <div class="modal-explanation">
        <h4>Explicación de los Indicadores:</h4>
        <p><span style="color:#00ffcc;font-weight:bold;">RSI (Relative Strength Index):</span> Mide la velocidad y cambio de los movimientos de precios, oscila entre 0 y 100. Valores por encima de 70 indican sobrecompra, mientras que valores por debajo de 30 indican sobreventa.</p>
        <p><span style="color:#4CAF50;font-weight:bold;">SMA (Media Móvil Simple) de 7 periodos (verde):</span> Calcula el promedio de los precios de cierre de los últimos 7 periodos, proporcionando una visión de la tendencia a corto plazo.</p>
        <p><span style="color:#FF8C00;font-weight:bold;">SMA (Media Móvil Simple) de 30 periodos (naranja):</span> Calcula el promedio de los precios de cierre de los últimos 30 periodos, ofreciendo una perspectiva de la tendencia a largo plazo.</p>
        <p><span style="color:#00BFFF;font-weight:bold;">Volumen (azul):</span> Representa la cantidad de operaciones realizadas en cada periodo, indicando la fuerza detrás de los movimientos de precio.</p>
        <p><span style="color:#EE82EE;font-weight:bold;">Línea IA (violeta):</span> Predicción basada en inteligencia artificial que estima la tendencia futura del precio según patrones históricos.</p>
        <h4>Consejo:</h4>
        <p id="adviceText">(Se llenará con recomendaciones basadas en indicadores)</p>
      </div>

      <div class="modal-footer">
        <span id="dataSource"></span>
      </div>
    </div>
  </div>

  <!-- Modal de Comparación -->
  <div id="compareModalOverlay">
    <div id="compareModalContent">
      <button class="btn btn-danger modalCloseBtn">Cerrar</button>
      <h2>Comparación de Criptomonedas</h2>
      <div id="compareSelectorsContainer" style="display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap;">
        <select id="compareCrypto1" class="btn btn-default">
          <option value="">Selecciona Cripto 1</option>
        </select>
        <select id="compareCrypto2" class="btn btn-default">
          <option value="">Selecciona Cripto 2</option>
        </select>
        <button id="compareBtn" class="btn btn-primary" disabled>Comparar</button> <!-- Inicialmente deshabilitado -->
      </div>
      <div id="comparisonChartContainer">
        <canvas id="comparisonChart"></canvas>
      </div>
      <table id="comparisonTable">
        <thead>
          <tr>
            <th>Métrica</th>
            <th id="metric1">Cripto 1</th>
            <th id="metric2">Cripto 2</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Precio Actual</td>
            <td id="price1">-</td>
            <td id="price2">-</td>
          </tr>
          <tr>
            <td>Variación Precio (24h)
              <span class="tooltip">Cambio porcentual del precio en las últimas 24 horas.</span>
            </td>
            <td id="priceChange1">-</td>
            <td id="priceChange2">-</td>
          </tr>
          <tr>
            <td>Capitalización de Mercado
              <span class="tooltip">Valor total de todas las monedas en circulación.</span>
            </td>
            <td id="marketCap1">-</td>
            <td id="marketCap2">-</td>
          </tr>
          <tr>
            <td>Volumen (24h)
              <span class="tooltip">Cantidad total de operaciones realizadas en las últimas 24 horas.</span>
            </td>
            <td id="volume1">-</td>
            <td id="volume2">-</td>
          </tr>
          <tr>
            <td>On-Balance Volume (OBV)
              <span class="tooltip">Mide la presión de compra y venta acumulativa basada en el volumen.</span>
            </td>
            <td id="obv1">-</td>
            <td id="obv2">-</td>
          </tr>
          <tr>
            <td>Sentimiento del Mercado
              <span class="tooltip">Evaluación del sentimiento general del mercado hacia la criptomoneda.</span>
            </td>
            <td id="sentiment1">-</td>
            <td id="sentiment2">-</td>
          </tr>
          <tr>
            <td>Supply Circulante
              <span class="tooltip">Cantidad de monedas actualmente en circulación.</span>
            </td>
            <td id="circulatingSupply1">-</td>
            <td id="circulatingSupply2">-</td>
          </tr>
          <tr>
            <td>Supply Total
              <span class="tooltip">Cantidad total de monedas que existirán.</span>
            </td>
            <td id="totalSupply1">-</td>
            <td id="totalSupply2">-</td>
          </tr>
          <tr>
            <td>Dominancia de Mercado
              <span class="tooltip">Porcentaje de la capitalización de mercado de la criptomoneda respecto al total del mercado cripto.</span>
            </td>
            <td id="marketDominance1">-</td>
            <td id="marketDominance2">-</td>
          </tr>
          <tr>
            <td>Número de Transacciones Diarias
              <span class="tooltip">Cantidad de transacciones realizadas en las últimas 24 horas.</span>
            </td>
            <td id="transactions1">-</td>
            <td id="transactions2">-</td>
          </tr>
          <tr>
            <td>RSI (14)
              <span class="tooltip">Mide la fortaleza o debilidad del activo en los últimos 14 periodos.</span>
            </td>
            <td id="rsi1">-</td>
            <td id="rsi2">-</td>
          </tr>
          <!-- Más métricas según necesidad -->
        </tbody>
      </table>
      <!-- Botón para expandir el gráfico en móvil -->
      <button id="verAnalisisCompareBtn" class="btn btn-warning">Ver Análisis</button>
      <!-- Botón para volver desde la vista expandida -->
      <button id="volverCompareBtn" class="btn btn-danger">Regresar</button>
      <!-- Recomendación de Comparación -->
      <div id="comparisonRecommendation"></div>
    </div>
  </div>

  <!-- Modal de Portafolio -->
  <div id="portfolioModalOverlay">
    <div id="portfolioModalContent">
      <button class="btn btn-danger modalCloseBtn">Cerrar</button>
      <h1>Mi Portafolio de Criptomonedas</h1>
      <table id="portfolioTable">
        <thead>
          <tr>
            <th>Criptomoneda</th>
            <th>Cantidad</th>
            <th>Precio de Compra</th>
            <th>Valor Invertido (USD)</th>
            <th>Fecha de Inversión</th>
            <th>Precio Actual</th>
            <th>Valor Actual</th>
            <th>Ganancia/Pérdida</th>
            <th>Acciones</th>
          </tr>
        </thead>
        <tbody>
          <!-- Los datos se cargarán dinámicamente aquí -->
        </tbody>
      </table>

      <div id="portfolioSummary">
        <div class="summary-item">Total Invertido: <span id="totalInvestedPortfolio" class="summary-value"></span></div>
        <div class="summary-item">Valor Total del Portafolio: <span id="totalPortfolioValuePortfolio" class="summary-value"></span></div>
        <div class="summary-item">Ganancia/Pérdida Total: <span id="totalProfitLossPortfolio" class="summary-value"></span></div>
        <div class="summary-item">Última Actualización: <span id="lastPortfolioUpdate" class="summary-value">(sin datos)</span></div> <!-- Nuevo campo para última actualización -->
      </div>

      <form id="addPortfolioForm">
        <div class="form-group">
          <label for="portfolioCryptoName">Criptomoneda</label>
          <select id="portfolioCryptoName" required>
            <option value="">Selecciona Criptomoneda</option>
          </select>
        </div>
        <div class="form-group">
          <label for="portfolioCryptoSymbol">Símbolo</label>
          <input type="text" id="portfolioCryptoSymbol" placeholder="Símbolo" readonly required>
        </div>
        <div class="form-group">
          <label for="portfolioCryptoAmount">Cantidad</label>
          <input type="number" id="portfolioCryptoAmount" placeholder="Cantidad" step="0.0000000001" required> <!-- Ajuste del step -->
        </div>
        <div class="form-group">
          <label for="portfolioCryptoBuyPrice">Precio de Compra</label>
          <input type="number" id="portfolioCryptoBuyPrice" placeholder="Precio de compra" step="0.0000000001" required> <!-- Ajuste del step -->
        </div>
        <div class="form-group">
          <label for="portfolioCryptoDate">Fecha de Inversión</label>
          <input type="date" id="portfolioCryptoDate" required>
        </div>
        <button type="submit" class="btn btn-success">Añadir Criptomoneda</button>
      </form>

      <!-- Botón para actualizar precios del portafolio -->
      <button id="updatePortfolioPricesBtn" class="btn btn-info" style="margin-top: 20px;">Actualizar Precios</button>
      <!-- Mostrar tiempo de actualización -->
      <p id="updateTimePortfolio" style="text-align: center; margin-top: 10px; color: #00ffcc;">Tiempo de actualización: 0 ms</p>
    </div>
  </div>

  <!-- Botón de Tema -->
  <button id="themeToggle" class="btn btn-info">Tema</button>

  <!-- Botón Silenciar Alertas -->
  <button id="silenciarAlertasBtn" class="btn btn-warning">Silenciar Alertas</button>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Chart.js Zoom Plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
  <!-- jQuery para el modal de portafolio -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <!-- DataTables para el modal de portafolio -->
  <script src="https://cdn.datatables.net/1.10.24/js/jquery.dataTables.min.js"></script>
  <link rel="stylesheet" href="https://cdn.datatables.net/1.10.24/css/jquery.dataTables.min.css">
  <!-- Font Awesome para íconos en el modal de portafolio -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

  <script>
    let chartInstance = null;
    let comparisonChartInstance = null; // Para el gráfico de comparación
    let portfolioChartInstance = null; // Para el gráfico de portafolio
    let cryptoData = [];
    let favorites = JSON.parse(localStorage.getItem('favorites')) || [];
    let priceAlerts = JSON.parse(localStorage.getItem('priceAlerts')) || {};
    let buyPrices = JSON.parse(localStorage.getItem('buyPrices')) || {};
    let currentModalCoinId = null;
    let currentModalCoinName = null;
    let currentModalPrice = null;
    let currentModalSymbol = null;
    let silenciarAlertas = false;
    let updateTimer = null;
    let favoritesActive = false; // Flag para controlar el filtro de favoritos
    let updateInterval = parseInt(localStorage.getItem('updateInterval')) || 30; // Intervalo por defecto

    // Referencias a elementos del DOM
    const body = document.body;
    const themeToggle = document.getElementById('themeToggle');
    const silenciarAlertasBtn = document.getElementById('silenciarAlertasBtn');
    const lastUpdateElement = document.getElementById('lastUpdate');
    const cryptoGrid = document.getElementById('cryptoGrid');
    const coinFilter = document.getElementById('coinFilter');
    const rsiFilter = document.getElementById('rsiFilter');
    const modalOverlay = document.getElementById('modalOverlay');
    const modalContent = document.getElementById('modalContent');
    const modalClose = modalContent.querySelector('.modalCloseBtn');
    const modalTitle = document.getElementById('modalTitle');
    const dataSource = document.getElementById('dataSource');
    const modalInfo = document.getElementById('modalInfo');
    const adviceText = document.getElementById('adviceText');
    const verAnalisisBtn = document.getElementById('verAnalisisBtn');
    const volverBtn = document.getElementById('volverBtn'); // Botón "Regresar"
    const lastUpdateModal = document.getElementById('lastUpdateModal');
    const priceAlertInput = document.getElementById('priceAlertInput');
    const setAlertBtn = document.getElementById('setAlertBtn');
    const buyPriceInput = document.getElementById('buyPriceInput');
    const setBuyPriceBtn = document.getElementById('setBuyPriceBtn');
    const clearBuyPriceBtn = document.getElementById('clearBuyPriceBtn');
    const profitLossText = document.getElementById('profitLossText');
    const btnFavoritos = document.getElementById('btnFavoritos');
    const btnVerTodos = document.getElementById('btnVerTodos');
    const btnPortfolio = document.getElementById('btnPortfolio'); // Nuevo botón
    const updateChartBtn = document.getElementById('updateChartBtn');

    // Sección de Comparación
    const compareCryptoBtn = document.getElementById('compareCryptoBtn');
    const compareModalOverlay = document.getElementById('compareModalOverlay');
    const compareModalContent = document.getElementById('compareModalContent');
    const compareModalClose = compareModalContent.querySelector('.modalCloseBtn');
    const compareCrypto1Select = document.getElementById('compareCrypto1');
    const compareCrypto2Select = document.getElementById('compareCrypto2');
    const compareBtn = document.getElementById('compareBtn'); // Botón de comparación dentro del modal
    const comparisonChartCtx = document.getElementById('comparisonChart').getContext('2d');
    const comparisonTable = document.getElementById('comparisonTable');
    const metric1Header = document.getElementById('metric1');
    const metric2Header = document.getElementById('metric2');
    const price1Cell = document.getElementById('price1');
    const price2Cell = document.getElementById('price2');
    const priceChange1Cell = document.getElementById('priceChange1'); // Nueva referencia
    const priceChange2Cell = document.getElementById('priceChange2'); // Nueva referencia
    const marketCap1Cell = document.getElementById('marketCap1');
    const marketCap2Cell = document.getElementById('marketCap2');
    const volume1Cell = document.getElementById('volume1');
    const volume2Cell = document.getElementById('volume2');
    const obv1Cell = document.getElementById('obv1');
    const obv2Cell = document.getElementById('obv2');
    const sentiment1Cell = document.getElementById('sentiment1');
    const sentiment2Cell = document.getElementById('sentiment2');
    const circulatingSupply1Cell = document.getElementById('circulatingSupply1');
    const circulatingSupply2Cell = document.getElementById('circulatingSupply2');
    const totalSupply1Cell = document.getElementById('totalSupply1');
    const totalSupply2Cell = document.getElementById('totalSupply2');
    const marketDominance1Cell = document.getElementById('marketDominance1');
    const marketDominance2Cell = document.getElementById('marketDominance2');
    const transactions1Cell = document.getElementById('transactions1');
    const transactions2Cell = document.getElementById('transactions2');
    const rsi1CellCompare = document.getElementById('rsi1');
    const rsi2CellCompare = document.getElementById('rsi2');
    const verAnalisisCompareBtn = document.getElementById('verAnalisisCompareBtn');
    const volverCompareBtn = document.getElementById('volverCompareBtn');
    const comparisonRecommendation = document.getElementById('comparisonRecommendation');

    // Modal de Portafolio
    const portfolioModalOverlay = document.getElementById('portfolioModalOverlay');
    const portfolioModalContent = document.getElementById('portfolioModalContent');
    const portfolioClose = portfolioModalContent.querySelector('.modalCloseBtn');
    const portfolioTable = document.getElementById('portfolioTable');
    const portfolioSummary = document.getElementById('portfolioSummary');
    const totalInvestedPortfolio = document.getElementById('totalInvestedPortfolio');
    const totalPortfolioValuePortfolio = document.getElementById('totalPortfolioValuePortfolio');
    const totalProfitLossPortfolio = document.getElementById('totalProfitLossPortfolio');
    const lastPortfolioUpdate = document.getElementById('lastPortfolioUpdate'); // Nuevo elemento
    const addPortfolioForm = document.getElementById('addPortfolioForm');
    const portfolioCryptoName = document.getElementById('portfolioCryptoName');
    const portfolioCryptoSymbol = document.getElementById('portfolioCryptoSymbol');
    const portfolioCryptoAmount = document.getElementById('portfolioCryptoAmount');
    const portfolioCryptoBuyPrice = document.getElementById('portfolioCryptoBuyPrice');
    const portfolioCryptoDate = document.getElementById('portfolioCryptoDate');
    const updatePortfolioPricesBtn = document.getElementById('updatePortfolioPricesBtn');
    const updateTimePortfolio = document.getElementById('updateTimePortfolio'); // Nuevo elemento para tiempo de actualización

    // Barra de progreso
    const progressOverlay = document.getElementById('progressOverlay');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const progressMessage = document.getElementById('progressMessage');

    // === 1) Manejo de tema (dark/light) ===
    const savedTheme = localStorage.getItem('theme') || 'dark';
    body.className = savedTheme;
    themeToggle.addEventListener('click', () => {
      body.className = (body.className === 'dark') ? 'light' : 'dark';
      localStorage.setItem('theme', body.className);
      // Actualizar colores de los gráficos si están activos
      if (chartInstance) {
        // Ajustar colores del gráfico
        chartInstance.options.scales.y.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y1.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.x.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y1.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.plugins.legend.labels.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.update();
      }
      if (comparisonChartInstance) {
        comparisonChartInstance.options.scales.y.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        comparisonChartInstance.options.scales.x.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        comparisonChartInstance.options.scales.y.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        comparisonChartInstance.options.plugins.legend.labels.color = body.className === 'dark' ? '#ffffff' : '#000000';
        comparisonChartInstance.update();
      }
      if (portfolioChartInstance) {
        portfolioChartInstance.options.scales.y.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        portfolioChartInstance.options.scales.x.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        portfolioChartInstance.options.scales.y.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        portfolioChartInstance.options.plugins.legend.labels.color = body.className === 'dark' ? '#ffffff' : '#000000';
        portfolioChartInstance.update();
      }
    });

    // === 2) Botón silenciar alertas (voz) ===
    silenciarAlertasBtn.addEventListener('click', () => {
      silenciarAlertas = !silenciarAlertas;
      silenciarAlertasBtn.textContent = silenciarAlertas ? "Activar Alertas" : "Silenciar Alertas";
    });

    // === 4) RSI y recomendación ===
    function calculateRSI(closePrices, period = 14) {
      if (closePrices.length < period) return null;
      let gains = 0;
      let losses = 0;
      for (let i = 1; i < period; i++) {
        const diff = closePrices[i] - closePrices[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      let avgGain = gains / (period - 1);
      let avgLoss = losses / (period - 1);

      let rsiArray = [null];
      for (let i = period; i < closePrices.length; i++) {
        const diff = closePrices[i] - closePrices[i - 1];
        const gain = diff > 0 ? diff : 0;
        const loss = diff < 0 ? -diff : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;

        if (avgLoss === 0) {
          rsiArray.push(100);
        } else {
          const rs = avgGain / avgLoss;
          rsiArray.push(100 - (100 / (1 + rs)));
        }
      }
      return rsiArray[rsiArray.length - 1];
    }

    function getRecommendationFromRSI(rsiValue) {
      if (rsiValue === null) {
        return { flag: 'neutral-flag', text: 'Neutral (Sin RSI)', state: 'neutral' };
      }
      if (rsiValue > 70) {
        return { flag: 'red-flag', text: 'Vender (RSI>70)', state: 'vender' };
      } else if (rsiValue < 30) {
        return { flag: 'green-flag', text: 'Comprar (RSI<30)', state: 'comprar' };
      } else {
        return { flag: 'neutral-flag', text: 'Esperar (RSI 30-70)', state: 'esperar' };
      }
    }

    // === 5) Voz (alertas) ===
    function speakMessage(text) {
      if (silenciarAlertas) return;
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'es-ES';
        utterance.rate = 1;
        utterance.pitch = 1;
        speechSynthesis.speak(utterance);
      }
    }

    // === 6) Creación de tarjetas (cards) para cada cripto en la pantalla principal ===
    function createCryptoCard(crypto, index, rsiRecommendation) {
      const binanceSymbol = (crypto.symbol.toUpperCase() + 'USDT');
      const isFav = favorites.includes(crypto.id);
      const star = isFav ? '★' : '☆';

      const card = document.createElement('div');
      card.className = 'crypto-card';
      card.setAttribute('data-coin-id', crypto.id);
      card.setAttribute('data-current-price', crypto.current_price);
      card.setAttribute('data-rsi-state', rsiRecommendation.state);

      card.innerHTML = `
        <div class="favorite-icon">${star}</div>
        <img src="${crypto.image}" alt="${crypto.name} logo" class="crypto-logo">
        <div class="crypto-name">${crypto.name}</div>
        <div class="crypto-price">$${crypto.current_price.toFixed(2)}</div>
        <div class="flag ${rsiRecommendation.flag}" title="RSI (Relative Strength Index): ${rsiRecommendation.text}">${rsiRecommendation.text}</div>
        <div class="mini-chart-container">
          <canvas id="miniChart-${index}" class="mini-chart"></canvas>
        </div>
      `;

      // Favorito
      card.querySelector('.favorite-icon').addEventListener('click', (e) => {
        e.stopPropagation();
        toggleFavorite(crypto.id, card);
      });

      // Abrir modal (clic o touch)
      card.addEventListener('click', () => {
        openModal(crypto.id, crypto.name, crypto.current_price, crypto.symbol.toUpperCase() + 'USDT');
      });

      return card;
    }

    function toggleFavorite(coinId, card) {
      if (favorites.includes(coinId)) {
        favorites = favorites.filter(f => f !== coinId);
        card.querySelector('.favorite-icon').textContent = '☆';
      } else {
        favorites.push(coinId);
        card.querySelector('.favorite-icon').textContent = '★';
      }
      localStorage.setItem('favorites', JSON.stringify(favorites));
      reorderCards();
      if (favoritesActive) {
        applyFilters();
      }
    }

    function reorderCards() {
      const cards = Array.from(document.querySelectorAll('.crypto-card'));
      const favCards = [];
      const otherCards = [];

      cards.forEach(card => {
        const coinId = card.getAttribute('data-coin-id');
        if (favorites.includes(coinId)) {
          favCards.push(card);
        } else {
          otherCards.push(card);
        }
      });

      cryptoGrid.innerHTML = '';
      favCards.forEach(c => cryptoGrid.appendChild(c));
      otherCards.forEach(c => cryptoGrid.appendChild(c));
    }

    // === 7) Carga de minigráfico (Binance) ===
    async function loadMiniChart(binanceSymbol, index) {
      try {
        // Utilizar un marco temporal fijo para mini gráficos, por ejemplo '5m'
        const miniTimeFrame = '5m';
        const endpoint = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=${miniTimeFrame}&limit=30`;
        const res = await fetch(endpoint, {cache:'no-store'});
        if (!res.ok) {
          console.warn(`No se pudo obtener datos de Binance para ${binanceSymbol}. Status: ${res.status}`);
          return false;
        }
        const klineData = await res.json();
        if (!Array.isArray(klineData) || klineData.length === 0) {
          console.warn(`No hay datos de kline para ${binanceSymbol}`);
          return false;
        }

        const closePrices = klineData.map(c => parseFloat(c[4]));
        const labels = klineData.map(c => {
          const date = new Date(c[0]);
          return `${date.getDate()}/${(date.getMonth()+1)} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
        });

        const miniCtx = document.getElementById(`miniChart-${index}`);
        if (!miniCtx) {
          console.warn(`Elemento canvas no encontrado para miniChart-${index}`);
          return false;
        }
        const miniChartCtx = miniCtx.getContext('2d');
        new Chart(miniChartCtx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              data: closePrices,
              borderColor: '#00ffcc',
              backgroundColor: 'rgba(0,255,204,0.1)',
              tension: 0.3,
              fill: true,
              pointRadius: 0
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { display: false },
              y: { display: false }
            },
            plugins: {
              legend: { display: false }
            }
          }
        });
        return true;
      } catch (e) {
        console.error('Error al cargar el mini gráfico:', e);
        return false;
      }
    }

    // === 8) PnL (Ganancia / Pérdida) en el modal ===
    function updateProfitLoss(coinId, currentPrice) {
      const buyVal = parseFloat(buyPrices[coinId] || 0);
      if (!isNaN(buyVal) && buyVal > 0) {
        const pnl = ((currentPrice - buyVal) / buyVal) * 100;
        let arrow = '';
        if (pnl > 0) {
          arrow = '<span class="green-recommendation">▲</span>';
        } else if (pnl < 0) {
          arrow = '<span class="red-recommendation">▼</span>';
        }
        profitLossText.innerHTML = `Ganancia/Perdida: ${pnl.toFixed(2)}% ${arrow}`;
      } else {
        profitLossText.textContent = `Ganancia/Perdida: 0%`;
      }
    }

    // === 9) Funciones para cargar TODAS las criptos o SOLO las favoritas ===
    async function fetchCryptoData(forceUpdate = false) {
      try {
        progressOverlay.style.display = 'flex';
        cryptoGrid.innerHTML = '';
        coinFilter.innerHTML = '<option value="all">Todas</option>';
        rsiFilter.value = 'all'; 
        btnFavoritos.disabled = true;
        btnVerTodos.disabled = true;
        btnPortfolio.disabled = true;
        coinFilter.disabled = true;
        rsiFilter.disabled = true;
        compareCryptoBtn.classList.remove('enabled');
        compareCryptoBtn.disabled = true;

        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=50&page=1&sparkline=false`;
        console.log(`Fetching data from CoinGecko: ${endpoint}`);
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error("No se obtuvieron datos de CoinGecko.");
        }
        cryptoData = data;

        const totalCryptos = data.length;
        let loadedCryptos = 0;

        // Llenar los select de comparación
        populateComparisonSelectors(data);

        // Llenar los select del modal de portafolio
        populatePortfolioCryptoSelector(data);

        // Procesar criptomonedas en batches para evitar sobrecarga de solicitudes
        const batchSize = 5; // Número de solicitudes simultáneas
        for (let i = 0; i < data.length; i += batchSize) {
          const batch = data.slice(i, i + batchSize);
          await Promise.all(batch.map(async (coin, idx) => {
            await createCardWithRSI(coin, i + idx, totalCryptos);
            loadedCryptos++;
            const progressPercentage = Math.round((loadedCryptos / totalCryptos) * 100);
            progressBar.style.width = `${progressPercentage}%`;
            progressText.textContent = `${progressPercentage}%`;
            progressMessage.textContent = `Cargando ${loadedCryptos} de ${totalCryptos} criptomonedas...`;
          }));
        }

        reorderCards();
        lastUpdateElement.textContent = `Última actualización: ${new Date().toLocaleString()}`;
        applyFilters();

        // Habilitar el botón de comparación
        compareCryptoBtn.classList.add('enabled');
        compareCryptoBtn.disabled = false;
        btnPortfolio.disabled = false;

        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      } catch (error) {
        console.error('Error al obtener datos:', error);
        alert(`Error al cargar criptomonedas: ${error.message}`);
        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        btnPortfolio.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      }
    }

    // Carga SOLO favoritas
    async function fetchFavoritesData() {
      try {
        progressOverlay.style.display = 'flex';
        cryptoGrid.innerHTML = '';
        coinFilter.innerHTML = '<option value="all">Todas</option>';
        rsiFilter.value = 'all'; 
        btnFavoritos.disabled = true;
        btnVerTodos.disabled = true;
        btnPortfolio.disabled = true;
        coinFilter.disabled = true;
        rsiFilter.disabled = true;
        compareCryptoBtn.classList.remove('enabled');
        compareCryptoBtn.disabled = true;

        if (favorites.length === 0) {
          // No hay favoritas, salimos
          progressOverlay.style.display = 'none';
          btnFavoritos.disabled = false;
          btnVerTodos.disabled = false;
          btnPortfolio.disabled = false;
          coinFilter.disabled = false;
          rsiFilter.disabled = false;
          return;
        }

        const favoritesIds = favorites.join('%2C'); 
        // Por ejemplo: "bitcoin%2Cethereum" en la query
        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${favoritesIds}&order=market_cap_desc&per_page=50&page=1&sparkline=false`;
        console.log(`Fetching favorite data from CoinGecko: ${endpoint}`);
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error("No se obtuvieron datos de las favoritas.");
        }
        cryptoData = data;

        const totalCryptos = data.length;
        let loadedCryptos = 0;

        // Llenar los select de comparación solo con favoritas
        populateComparisonSelectors(data, true);

        // Llenar los select del modal de portafolio
        populatePortfolioCryptoSelector(data);

        // Procesar criptomonedas en batches para evitar sobrecarga de solicitudes
        const batchSize = 5; // Número de solicitudes simultáneas
        for (let i = 0; i < data.length; i += batchSize) {
          const batch = data.slice(i, i + batchSize);
          await Promise.all(batch.map(async (coin, idx) => {
            await createCardWithRSI(coin, i + idx, totalCryptos);
            loadedCryptos++;
            const progressPercentage = Math.round((loadedCryptos / totalCryptos) * 100);
            progressBar.style.width = `${progressPercentage}%`;
            progressText.textContent = `${progressPercentage}%`;
            progressMessage.textContent = `Cargando favoritas (${loadedCryptos}/${totalCryptos})...`;
          }));
        }

        reorderCards();
        lastUpdateElement.textContent = `Última actualización: ${new Date().toLocaleString()}`;
        applyFilters();

        // Habilitar el botón de comparación
        compareCryptoBtn.classList.add('enabled');
        compareCryptoBtn.disabled = false;
        btnPortfolio.disabled = false;

        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      } catch (error) {
        console.error('Error al cargar favoritas:', error);
        alert(`Error al cargar favoritas: ${error.message}`);
        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        btnPortfolio.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      }
    }

    // === 10) Función para Crear Card con RSI ===
    async function createCardWithRSI(coin, index, totalCryptos) {
      const binanceSymbol = (coin.symbol.toUpperCase() + 'USDT');
      let rsiValue = null;
      try {
        const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=5m&limit=30`, { cache: 'no-store' }); // Usando '5m' para mini gráficos
        if (res.ok) {
          const klineData = await res.json();
          const closePrices = klineData.map(c => parseFloat(c[4]));
          if (closePrices.length > 0) {
            rsiValue = calculateRSI(closePrices, 14);
          }
        } else {
          console.warn(`No se pudo obtener datos de Binance para ${binanceSymbol}. Status: ${res.status}`);
        }
      } catch (err) {
        console.error(`Error al obtener RSI para ${coin.name}:`, err);
        // error silencioso
      }
      const rsiRec = getRecommendationFromRSI(rsiValue);

      if (!silenciarAlertas && favorites.includes(coin.id) && rsiValue !== null) {
        const percentAlert = parseFloat(priceAlerts['globalPercentAlert'] || 5);
        if (rsiValue >= 70) {
          const buyVal = parseFloat(buyPrices[coin.id] || 0);
          if (buyVal > 0) {
            const pnl = ((coin.current_price - buyVal) / buyVal) * 100;
            if (pnl >= percentAlert) {
              speakMessage(`Se sugiere vender ${coin.name}. Ganancia de ${pnl.toFixed(2)} porciento, RSI: ${rsiValue.toFixed(2)}`);
            }
          }
        } else if (rsiValue < 30) {
          const buyVal = parseFloat(buyPrices[coin.id] || 0);
          if (buyVal === 0) {
            speakMessage(`Se sugiere comprar ${coin.name}. RSI: ${rsiValue.toFixed(2)}. Sin precio de compra configurado.`);
          }
        }
      }

      const card = createCryptoCard(coin, index, rsiRec);
      cryptoGrid.appendChild(card);

      // Añadir opciones al filtro de criptomonedas
      // Verificar si la opción ya existe para evitar duplicados
      if (!Array.from(coinFilter.options).some(option => option.value === coin.id)) {
        const opt = document.createElement('option');
        opt.value = coin.id;
        opt.textContent = coin.name;
        coinFilter.appendChild(opt);
      }

      // Añadir opciones a los selects de comparación
      if (!compareCrypto1Select.querySelector(`option[value="${coin.id}"]`)) {
        const opt1 = document.createElement('option');
        opt1.value = coin.id;
        opt1.textContent = coin.name;
        compareCrypto1Select.appendChild(opt1);
      }
      if (!compareCrypto2Select.querySelector(`option[value="${coin.id}"]`)) {
        const opt2 = document.createElement('option');
        opt2.value = coin.id;
        opt2.textContent = coin.name;
        compareCrypto2Select.appendChild(opt2);
      }

      // Añadir opciones al selector de criptomonedas en el modal de portafolio
      if (!portfolioCryptoName.querySelector(`option[value="${coin.id}"]`)) {
        const optPortfolio = document.createElement('option');
        optPortfolio.value = coin.id;
        optPortfolio.textContent = coin.name;
        portfolioCryptoName.appendChild(optPortfolio);
      }

      const loaded = await loadMiniChart(binanceSymbol, index);
      if (!loaded) {
        card.querySelector('.mini-chart-container').innerHTML = `<p class="no-chart-text">Sin datos de gráfico</p>`;
      }
    }

    // === 11) Carga y Actualización de UNA sola cripto (para el modal) ===
    // Esto se usará cuando en el modal se presione "Actualizar", para NO recargar las 50.
    async function fetchSingleCoinData(coinId) {
      try {
        // Llamada a la API para 1 sola criptomoneda
        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coinId}&order=market_cap_desc&per_page=1&page=1&sparkline=false`;
        console.log(`Fetching single coin data from CoinGecko: ${endpoint}`);
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error(`No se obtuvieron datos para ${coinId}.`);
        }
        const coin = data[0];
        currentModalCoinId = coin.id;
        currentModalCoinName = coin.name;
        currentModalPrice = coin.current_price;
        currentModalSymbol = coin.symbol.toUpperCase() + 'USDT';

        // Volvemos a cargar el modal con loadModalData
        await loadModalData(currentModalCoinId, currentModalCoinName, currentModalPrice, currentModalSymbol);
      } catch (error) {
        console.error('Error al obtener datos de una sola criptomoneda:', error);
        alert(`Error al actualizar ${coinId}: ${error.message}`);
      }
    }

    // === 12) Apertura del modal ===
    async function openModal(coinId, coinName, currentPrice, binanceSymbol) {
      currentModalCoinId = coinId;
      currentModalCoinName = coinName;
      currentModalPrice = currentPrice;
      currentModalSymbol = binanceSymbol;
      // Inicializar el marco temporal del modal a '5m'
      modalTimeFrameFilter.value = '5m';
      await loadModalData(coinId, coinName, currentPrice, binanceSymbol);
    }

    // === 13) Carga del modal (gráfico principal) ===
    async function loadModalData(coinId, coinName, currentPrice, binanceSymbol) {
      try {
        const modalTimeFrame = modalTimeFrameFilter.value; // Obtener el marco temporal seleccionado en el modal
        // Verificar si el intervalo es soportado por Binance
        const supportedIntervals = ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '8h', '12h', '1d', '3d', '1w', '1M'];
        if (!supportedIntervals.includes(modalTimeFrame)) {
          throw new Error(`Intervalo de tiempo "${modalTimeFrame}" no soportado por Binance.`);
        }

        const endpoint = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=${modalTimeFrame}&limit=100`;
        console.log(`Fetching modal data from Binance: ${endpoint}`);
        const response = await fetch(endpoint, {cache:'no-store'});
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const klineData = await response.json();
        if (!Array.isArray(klineData) || klineData.length === 0) {
          throw new Error(`Sin datos para ${coinName}.`);
        }

        const closePrices = klineData.map(c => parseFloat(c[4]));
        const volumes = klineData.map(c => parseFloat(c[5]));
        const labels = klineData.map(c => {
          const date = new Date(c[0]);
          const year = String(date.getFullYear()).slice(-2); // two-digit year
          return `${date.getDate()}/${(date.getMonth()+1)}/${year} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
        });

        // RSI
        const rsiValue = calculateRSI(closePrices, 14);
        const rsiRec = getRecommendationFromRSI(rsiValue);

        modalTitle.textContent = `${coinName} - Tendencia: ${rsiRec.text}`;
        dataSource.textContent = endpoint;

        modalInfo.innerHTML = `
          <p>Precio Actual: $${currentPrice.toFixed(2)}</p>
          <p>RSI (14): ${rsiValue ? rsiValue.toFixed(2) : 'N/A'}</p>
        `;

        modalOverlay.style.display = 'flex';

        // Destruimos un chart anterior
        if (chartInstance) {
          chartInstance.destroy();
        }

        // IA line
        const aiPredictions = generateAIPrediction(closePrices);
        const aiLabels = [];
        for (let i = 1; i <= aiPredictions.length; i++) {
          aiLabels.push(`Futuro+${i}`);
        }

        // SMA
        const shortSMA = calculateSMA(closePrices, 7);
        const longSMA = calculateSMA(closePrices, 30);

        // Preparar los datos para el gráfico
        const aiLine = Array(closePrices.length).fill(null).concat(aiPredictions);

        setTimeout(() => {
          chartInstance = new Chart(document.getElementById('cryptoChart').getContext('2d'), {
            data: {
              labels: labels.concat(aiLabels),
              datasets: [
                {
                  type: 'line',
                  label: `${coinName} (USD)`,
                  data: closePrices.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#00ffcc',
                  backgroundColor: 'rgba(0,255,204,0.1)',
                  tension: 0.3,
                  fill: true,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: `SMA (7)`,
                  data: shortSMA.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#FFD700',
                  fill: false,
                  pointRadius: 0,
                  tension: 0.2,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: `SMA (30)`,
                  data: longSMA.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#FF8C00',
                  fill: false,
                  pointRadius: 0,
                  tension: 0.2,
                  yAxisID: 'y',
                },
                {
                  type: 'bar',
                  label: 'Volumen',
                  data: volumes.concat(Array(aiPredictions.length).fill(null)),
                  backgroundColor: 'rgba(0,191,255,0.3)',
                  borderColor: '#00BFFF',
                  borderWidth: 1,
                  yAxisID: 'y1'
                },
                {
                  type: 'line',
                  label: 'Línea IA (Predicción)',
                  data: aiLine,
                  borderColor: '#EE82EE',
                  borderDash: [2, 2],
                  pointRadius: 0,
                  fill: false,
                  tension: 0.2,
                  yAxisID: 'y',
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              scales: {
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Precio (USD)',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Volumen',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  },
                  grid: {
                    drawOnChartArea: false,
                  },
                },
                x: {
                  ticks: { 
                    color: body.className === 'dark' ? '#ffffff' : '#000000',
                    callback: function(value, index, values) {
                      return this.getLabelForValue(value);
                    }
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                },
                zoom: { // Configuración del plugin de zoom
                  pan: {
                    enabled: true,
                    mode: 'xy',
                  },
                  zoom: {
                    wheel: {
                      enabled: true,
                    },
                    pinch: {
                      enabled: true
                    },
                    mode: 'xy',
                  }
                }
              },
            }
          });
          chartInstance.update();
        }, 100);

        fillAdviceAndComments();
        lastUpdateModal.textContent = `Última actualización: ${new Date().toLocaleString()}`;

        if (buyPrices[coinId]) {
          buyPriceInput.value = buyPrices[coinId];
        } else {
          buyPriceInput.value = "";
        }
        updateProfitLoss(coinId, currentPrice);
      } catch (error) {
        console.error('Error al mostrar modal con gráfico:', error);
        alert(`Error al cargar datos del gráfico: ${error.message}`);
        modalTitle.textContent = `${coinName} - Sin datos de gráfico`;
        modalInfo.innerHTML = `<p>No se pudieron obtener datos del gráfico. Intente más tarde.</p>`;
        adviceText.textContent = "No hay suficientes datos para dar un consejo.";
        dataSource.textContent = "";
        modalOverlay.style.display = 'flex';
        lastUpdateModal.textContent = "Última actualización: (sin datos)";
      }
    }

    function fillAdviceAndComments() {
      const randomAdvice = [
        "Observa también el volumen para mayor precisión.",
        "Ten en cuenta la tendencia global del mercado.",
        "Considera noticias recientes que puedan afectar al activo.",
        "Combina RSI con otras medias móviles para más eficacia.",
        "Analiza la volatilidad antes de comprar o vender."
      ];
      adviceText.textContent = randomAdvice[Math.floor(Math.random() * randomAdvice.length)];
    }

    // === 14) Cierre del modal ===
    modalClose.addEventListener('click', () => {
      cerrarModal();
    });

    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) {
        cerrarModal();
      }
    });

    function cerrarModal() {
      modalOverlay.classList.remove('expanded-view'); // Remover clase de vista expandida si existe
      cerrarVistaExpandida();
      modalOverlay.style.display = 'none';
    }

    // === 15) Botón "Ver Análisis" (Expandir gráfico) ===
    verAnalisisBtn.addEventListener('click', () => {
      const isMobile = window.matchMedia("only screen and (max-width: 768px)").matches;
      if (isMobile) {
        // Expandir el modal a pantalla completa
        modalOverlay.classList.add('expanded-view');

        if (chartInstance) {
          // Reajustar el tamaño del gráfico
          chartInstance.resize();
          chartInstance.update();
        }

        // Mostrar botón "Regresar" y ocultar "Ver Análisis"
        verAnalisisBtn.style.display = 'none';
        volverBtn.style.display = 'block';
      } else {
        // Para escritorio, podrías implementar otra funcionalidad si lo deseas
        alert("Esta funcionalidad está optimizada para dispositivos móviles.");
      }
    });

    // === 16) Botón "Volver" (Revertir expansión del gráfico) ===
    volverBtn.addEventListener('click', () => {
      cerrarVistaExpandida();
    });

    function cerrarVistaExpandida() {
      modalOverlay.classList.remove('expanded-view');
      if (chartInstance) {
        chartInstance.resize();
        chartInstance.update();
      }

      // Mostrar botón "Ver Análisis" y ocultar "Regresar"
      verAnalisisBtn.style.display = 'block';
      volverBtn.style.display = 'none';
    }

    // === 17) Botones de Alertas ===
    setAlertBtn.addEventListener('click', () => {
      const percentVal = parseFloat(priceAlertInput.value);
      if (!isNaN(percentVal) && percentVal > 0) {
        priceAlerts['globalPercentAlert'] = percentVal;
        localStorage.setItem('priceAlerts', JSON.stringify(priceAlerts));
        speakMessage(`Has establecido la alerta de ganancia en ${percentVal} porciento.`);
      } else {
        alert("Por favor, ingresa un valor válido para la alerta.");
      }
    });

    setBuyPriceBtn.addEventListener('click', () => {
      if (currentModalCoinId && buyPriceInput.value) {
        const buyPrice = parseFloat(buyPriceInput.value);
        if (!isNaN(buyPrice) && buyPrice > 0) {
          buyPrices[currentModalCoinId] = buyPrice;
          localStorage.setItem('buyPrices', JSON.stringify(buyPrices));
          updateProfitLoss(currentModalCoinId, currentModalPrice);
          speakMessage(`Precio de compra establecido para ${currentModalCoinId} en ${buyPrice} dólares.`);
        } else {
          alert("Por favor, ingresa un precio de compra válido.");
        }
      } else {
        alert("No hay una criptomoneda seleccionada o el precio de compra está vacío.");
      }
    });

    clearBuyPriceBtn.addEventListener('click', () => {
      if (currentModalCoinId) {
        delete buyPrices[currentModalCoinId];
        localStorage.setItem('buyPrices', JSON.stringify(buyPrices));
        buyPriceInput.value = "";
        profitLossText.textContent = "Ganancia/Perdida: 0%";
        speakMessage(`Precio de compra eliminado para ${currentModalCoinId}.`);
      }
    });

    // === 18) Botones de Favoritos, Ver Todos y Mi Portafolio ===
    btnFavoritos.addEventListener('click', async () => {
      favoritesActive = true;
      await fetchFavoritesData();
    });

    btnVerTodos.addEventListener('click', async () => {
      favoritesActive = false;
      await fetchCryptoData(true);
    });

    btnPortfolio.addEventListener('click', () => {
      openPortfolioModal();
    });

    // === 19) Botón "Actualizar" en el Modal ===
    updateChartBtn.addEventListener('click', async () => {
      // Llamamos a fetchSingleCoinData para actualizar solo esta cripto
      if (currentModalCoinId) {
        await fetchSingleCoinData(currentModalCoinId);
      }
    });

    // === 20) Selector de Marco Temporal en el Modal ===
    modalTimeFrameFilter.addEventListener('change', async () => {
      // Si el modal está abierto, actualizar su gráfico
      if (modalOverlay.style.display === 'flex' && currentModalCoinId) {
        await loadModalData(currentModalCoinId, currentModalCoinName, currentModalPrice, currentModalSymbol);
      }
    });

    // === 21) Función de Filtros ===
    function applyFilters() {
      const selectedCoin = coinFilter.value;
      const selectedRSI = rsiFilter.value;

      const cards = document.querySelectorAll('.crypto-card');
      cards.forEach(card => {
        let display = true;

        // Filtro de Favoritos
        if (favoritesActive) {
          const coinId = card.getAttribute('data-coin-id');
          if (!favorites.includes(coinId)) {
            display = false;
          }
        }

        // Filtro de Criptomoneda
        if (selectedCoin !== 'all') {
          const coinId = card.getAttribute('data-coin-id');
          if (coinId !== selectedCoin) {
            display = false;
          }
        }

        // Filtro de RSI
        if (selectedRSI !== 'all') {
          const rsiState = card.getAttribute('data-rsi-state');
          if (selectedRSI !== rsiState) {
            display = false;
          }
        }

        card.style.display = display ? 'block' : 'none';
      });

      // Reordenar después de aplicar filtros
      reorderCards();
    }

    function resetFilters() {
      coinFilter.value = 'all';
      rsiFilter.value = 'all';
      cryptoGrid.querySelectorAll('.crypto-card').forEach(card => {
        card.style.display = 'block';
      });
      reorderCards();
    }

    // === 23) Función de Inicio ===
    async function initialize() {
      // Añadir Event Listeners para los filtros
      coinFilter.addEventListener('change', applyFilters);
      rsiFilter.addEventListener('change', applyFilters);

      // Añadir Event Listener para el botón de Comparación
      compareCryptoBtn.addEventListener('click', () => {
        openCompareModal();
      });

      // Añadir Event Listener para el cierre del modal de comparación
      compareModalClose.addEventListener('click', () => {
        cerrarCompareModal();
      });

      // Añadir Event Listener para el modal de comparación al hacer clic fuera del contenido
      compareModalOverlay.addEventListener('click', (e) => {
        if (e.target === compareModalOverlay) {
          cerrarCompareModal();
        }
      });

      // Añadir Event Listener para el botón "Regresar" en el modal de comparación
      volverCompareBtn.addEventListener('click', () => {
        cerrarVistaExpandidaCompare();
      });

      // Event Listeners para habilitar el botón "Comparar" dentro del modal
      compareCrypto1Select.addEventListener('change', checkCompareButtonState);
      compareCrypto2Select.addEventListener('change', checkCompareButtonState);

      // Añadir Event Listener para el botón "Regresar" en el modal de portafolio
      portfolioModalContent.querySelector('.modalCloseBtn').addEventListener('click', () => {
        cerrarPortfolioModal();
      });

      // Añadir Event Listener para el modal de portafolio al hacer clic fuera del contenido
      portfolioModalOverlay.addEventListener('click', (e) => {
        if (e.target === portfolioModalOverlay) {
          cerrarPortfolioModal();
        }
      });

      // Añadir Event Listener para el formulario de agregar criptomonedas al portafolio
      addPortfolioForm.addEventListener('submit', handleAddPortfolioCrypto);

      // Añadir Event Listener para el selector de criptomonedas en el portafolio para auto-llenar el símbolo
      portfolioCryptoName.addEventListener('change', autoFillPortfolioSymbol);

      // Añadir Event Listener para el botón de actualizar precios del portafolio
      updatePortfolioPricesBtn.addEventListener('click', updatePortfolioPrices);

      // Añadir Event Listener para el selector de intervalo de actualización
      document.getElementById('updateInterval').addEventListener('change', (e) => {
        updateInterval = parseInt(e.target.value);
        localStorage.setItem('updateInterval', updateInterval);
        startUpdateTimer();
      });

      // Primer fetch según estado inicial (Ver Todos o Favoritos)
      if (favoritesActive) {
        await fetchFavoritesData();
      } else {
        await fetchCryptoData(false);
      }

      // Iniciar el timer de actualización
      startUpdateTimer();
    }

    // === 24) Timer de Actualización ===
    function startUpdateTimer() {
      if (updateTimer) {
        clearInterval(updateTimer);
      }
      updateTimer = setInterval(async () => {
        if (favoritesActive) {
          await fetchFavoritesData();
        } else {
          await fetchCryptoData(true);
        }
      }, updateInterval * 1000);
    }

    // === 25) Funciones Extra ===
    function calculateSMA(data, length) {
      const sma = [];
      for (let i = 0; i < data.length; i++) {
        if (i < length - 1) {
          sma.push(null);
        } else {
          const slice = data.slice(i - length + 1, i + 1);
          const sum = slice.reduce((a, b) => a + b, 0);
          sma.push(sum / length);
        }
      }
      return sma;
    }

    function generateAIPrediction(closePrices) {
      const predictions = [];
      const lastPrice = closePrices[closePrices.length - 1];
      for (let i = 1; i <= 10; i++) {
        const factor = 1 + (Math.random() - 0.5) * 0.02;
        predictions.push(lastPrice * factor);
      }
      return predictions;
    }

    // === 26) Función para Llenar los Selects de Comparación y Portafolio ===
    function populateComparisonSelectors(data, isFavorites = false) {
      const select1 = compareCrypto1Select;
      const select2 = compareCrypto2Select;
      // Limpiar opciones excepto la primera
      select1.innerHTML = '<option value="">Selecciona Cripto 1</option>';
      select2.innerHTML = '<option value="">Selecciona Cripto 2</option>';

      data.forEach(coin => {
        const option1 = document.createElement('option');
        option1.value = coin.id;
        option1.textContent = coin.name;
        select1.appendChild(option1);

        const option2 = document.createElement('option');
        option2.value = coin.id;
        option2.textContent = coin.name;
        select2.appendChild(option2);
      });
    }

    // Función para llenar el selector de criptomonedas en el modal de portafolio
    function populatePortfolioCryptoSelector(data) {
      const select = portfolioCryptoName;
      select.innerHTML = '<option value="">Selecciona Criptomoneda</option>';
      data.forEach(coin => {
        const option = document.createElement('option');
        option.value = coin.id;
        option.textContent = coin.name;
        select.appendChild(option);
      });
    }

    // === 27) Función para Comparar Criptomonedas ===
    compareBtn.addEventListener('click', async () => {
      const crypto1 = compareCrypto1Select.value;
      const crypto2 = compareCrypto2Select.value;

      if (!crypto1 || !crypto2) {
        alert('Por favor, selecciona ambas criptomonedas para comparar.');
        return;
      }

      if (crypto1 === crypto2) {
        alert('Selecciona dos criptomonedas diferentes para comparar.');
        return;
      }

      try {
        // Mostrar barra de progreso
        progressOverlay.style.display = 'flex';
        progressMessage.textContent = 'Cargando datos para la comparación...';
        progressBar.style.width = '0%';
        progressText.textContent = '0%';

        // Fetch data desde CoinGecko
        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${crypto1},${crypto2}&order=market_cap_desc&per_page=2&page=1&sparkline=false`;
        console.log(`Fetching comparison data from CoinGecko: ${endpoint}`);
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length < 2) {
          throw new Error("No se obtuvieron suficientes datos de CoinGecko para la comparación.");
        }

        const [data1, data2] = data;

        // Actualizar la tabla
        metric1Header.textContent = data1.name;
        metric2Header.textContent = data2.name;
        price1Cell.textContent = `$${data1.current_price.toLocaleString()}`;
        price2Cell.textContent = `$${data2.current_price.toLocaleString()}`;
        // Variación del Precio (24h)
        priceChange1Cell.textContent = data1.price_change_percentage_24h !== null ? `${data1.price_change_percentage_24h.toFixed(2)}%` : 'N/A';
        priceChange2Cell.textContent = data2.price_change_percentage_24h !== null ? `${data2.price_change_percentage_24h.toFixed(2)}%` : 'N/A';
        // Capitalización de Mercado
        marketCap1Cell.textContent = data1.market_cap ? `$${data1.market_cap.toLocaleString()}` : 'N/A';
        marketCap2Cell.textContent = data2.market_cap ? `$${data2.market_cap.toLocaleString()}` : 'N/A';
        // Volumen (24h)
        volume1Cell.textContent = data1.total_volume ? `$${data1.total_volume.toLocaleString()}` : 'N/A';
        volume2Cell.textContent = data2.total_volume ? `$${data2.total_volume.toLocaleString()}` : 'N/A';
        // RSI (14) - Simulación, ya que CoinGecko no proporciona RSI
        // Para la comparación, utilizaremos un RSI simulado basado en la variación de precios
        const rsiValue1 = simulateRSI(data1.price_change_percentage_24h);
        const rsiValue2 = simulateRSI(data2.price_change_percentage_24h);
        rsi1CellCompare.textContent = rsiValue1 !== null ? rsiValue1.toFixed(2) : 'N/A';
        rsi2CellCompare.textContent = rsiValue2 !== null ? rsiValue2.toFixed(2) : 'N/A';

        // On-Balance Volume (OBV) - Simulación
        obv1Cell.textContent = calculateOBV(data1) || 'N/A';
        obv2Cell.textContent = calculateOBV(data2) || 'N/A';

        // Sentimiento del Mercado - Simulación
        sentiment1Cell.textContent = getMarketSentiment();
        sentiment2Cell.textContent = getMarketSentiment();

        // Supply Circulante y Total
        circulatingSupply1Cell.textContent = data1.circulating_supply ? `${data1.circulating_supply.toLocaleString()} ${data1.symbol.toUpperCase()}` : 'N/A';
        circulatingSupply2Cell.textContent = data2.circulating_supply ? `${data2.circulating_supply.toLocaleString()} ${data2.symbol.toUpperCase()}` : 'N/A';
        totalSupply1Cell.textContent = data1.total_supply ? `${data1.total_supply.toLocaleString()} ${data1.symbol.toUpperCase()}` : 'N/A';
        totalSupply2Cell.textContent = data2.total_supply ? `${data2.total_supply.toLocaleString()} ${data2.symbol.toUpperCase()}` : 'N/A';

        // Dominancia de Mercado
        marketDominance1Cell.textContent = data1.market_cap_rank ? `${data1.market_cap_rank}` : 'N/A';
        marketDominance2Cell.textContent = data2.market_cap_rank ? `${data2.market_cap_rank}` : 'N/A';

        // Número de Transacciones Diarias - Simulación
        transactions1Cell.textContent = getDailyTransactions();
        transactions2Cell.textContent = getDailyTransactions();

        // Fetch historiales de precios para el gráfico
        const days = 30; // Puedes hacer que el usuario elija el período
        const history1 = await fetch(`https://api.coingecko.com/api/v3/coins/${crypto1}/market_chart?vs_currency=usd&days=${days}`);
        const history2 = await fetch(`https://api.coingecko.com/api/v3/coins/${crypto2}/market_chart?vs_currency=usd&days=${days}`);
        const historyData1 = await history1.json();
        const historyData2 = await history2.json();

        const labels1 = historyData1.prices.map(price => {
          const date = new Date(price[0]);
          return `${date.getMonth()+1}/${date.getDate()}`;
        });
        const labels2 = historyData2.prices.map(price => {
          const date = new Date(price[0]);
          return `${date.getMonth()+1}/${date.getDate()}`;
        });

        // Asegurar que ambas series tengan el mismo número de etiquetas
        const minLength = Math.min(labels1.length, labels2.length);
        const labels = labels1.slice(-minLength);
        const prices1 = historyData1.prices.slice(-minLength).map(price => price[1]);
        const prices2 = historyData2.prices.slice(-minLength).map(price => price[1]);

        // Calcular RSI para ambas criptomonedas (simulado)
        const rsiValue1Final = calculateRSI(prices1, 14);
        const rsiValue2Final = calculateRSI(prices2, 14);
        rsi1CellCompare.textContent = rsiValue1Final !== null ? rsiValue1Final.toFixed(2) : 'N/A';
        rsi2CellCompare.textContent = rsiValue2Final !== null ? rsiValue2Final.toFixed(2) : 'N/A';

        // Crear o actualizar el gráfico de comparación
        if (comparisonChartInstance) {
          comparisonChartInstance.data.labels = labels;
          comparisonChartInstance.data.datasets[0].data = prices1;
          comparisonChartInstance.data.datasets[1].data = prices2;
          comparisonChartInstance.update();
        } else {
          comparisonChartInstance = new Chart(comparisonChartCtx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: data1.name,
                  data: prices1,
                  borderColor: 'rgba(75, 192, 192, 1)',
                  backgroundColor: 'rgba(75, 192, 192, 0.2)',
                  fill: true,
                  tension: 0.3,
                },
                {
                  label: data2.name,
                  data: prices2,
                  borderColor: 'rgba(255, 99, 132, 1)',
                  backgroundColor: 'rgba(255, 99, 132, 0.2)',
                  fill: true,
                  tension: 0.3,
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              scales: {
                x: { display: true },
                y: { 
                  display: true,
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Precio (USD)',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                },
                zoom: { // Configuración del plugin de zoom
                  pan: {
                    enabled: true,
                    mode: 'xy',
                  },
                  zoom: {
                    wheel: {
                      enabled: true,
                    },
                    pinch: {
                      enabled: true
                    },
                    mode: 'xy',
                  }
                }
              },
            }
          });
        }

        // Determinar recomendaciones basadas en RSI
        const recommendation1 = determineAction(rsiValue1Final);
        const recommendation2 = determineAction(rsiValue2Final);

        // Mostrar recomendaciones debajo del gráfico
        comparisonRecommendation.innerHTML = `
          <p>${data1.name}: <span class="${getRecommendationClass(recommendation1)}">${recommendation1}</span></p>
          <p>${data2.name}: <span class="${getRecommendationClass(recommendation2)}">${recommendation2}</span></p>
        `;

        // Actualizar el progreso
        progressBar.style.width = '100%';
        progressText.textContent = '100%';
        progressMessage.textContent = 'Comparación completada.';
        setTimeout(() => {
          progressOverlay.style.display = 'none';
        }, 500);
      } catch (error) {
        console.error('Error al comparar criptomonedas:', error);
        alert(`Error: ${error.message}`);
        progressOverlay.style.display = 'none';
      }
    });

    // === 28) Función para Cerrar el Modal de Comparación ===
    function cerrarCompareModal() {
      compareModalOverlay.classList.remove('expanded-view');
      cerrarVistaExpandidaCompare();
      compareModalOverlay.style.display = 'none';
      // Limpiar recomendaciones
      comparisonRecommendation.innerHTML = '';
    }

    // === 29) Función para Abrir el Modal de Comparación ===
    function openCompareModal() {
      compareModalOverlay.style.display = 'flex';
    }

    // === 30) Botón "Ver Análisis" en el Modal de Comparación ===
    verAnalisisCompareBtn.addEventListener('click', () => {
      const isMobile = window.matchMedia("only screen and (max-width: 768px)").matches;
      if (isMobile) {
        // Expandir el modal a pantalla completa
        compareModalOverlay.classList.add('expanded-view');

        if (comparisonChartInstance) {
          // Reajustar el tamaño del gráfico
          comparisonChartInstance.resize();
          comparisonChartInstance.update();
        }

        // Mostrar botón "Regresar" y ocultar "Ver Análisis"
        verAnalisisCompareBtn.style.display = 'none';
        volverCompareBtn.style.display = 'block';
      } else {
        // Para escritorio, podrías implementar otra funcionalidad si lo deseas
        alert("Esta funcionalidad está optimizada para dispositivos móviles.");
      }
    });

    // === 31) Botón "Volver" en el Modal de Comparación ===
    volverCompareBtn.addEventListener('click', () => {
      cerrarVistaExpandidaCompare();
    });

    function cerrarVistaExpandidaCompare() {
      compareModalOverlay.classList.remove('expanded-view');
      if (comparisonChartInstance) {
        comparisonChartInstance.resize();
        comparisonChartInstance.update();
      }

      // Mostrar botón "Ver Análisis" y ocultar "Regresar"
      verAnalisisCompareBtn.style.display = 'block';
      volverCompareBtn.style.display = 'none';
    }

    // === 32) Función de Filtros ===
    // Ya implementada en applyFilters()

    // === 34) Funciones para el Modal de Portafolio ===

    // Abrir el modal de portafolio
    function openPortfolioModal() {
      portfolioModalOverlay.style.display = 'flex';
      loadPortfolioData();
    }

    // Cerrar el modal de portafolio
    function cerrarPortfolioModal() {
      portfolioModalOverlay.style.display = 'none';
    }

    // Gestionar el portafolio
    let portfolio = JSON.parse(localStorage.getItem('portfolio')) || [];

    function loadPortfolioData() {
      updatePortfolioTable();
    }

    function updatePortfolioTable() {
      const tableBody = portfolioTable.querySelector('tbody');
      tableBody.innerHTML = '';
      let totalInvested = 0;
      let totalPortfolioValue = 0;
      let totalProfitLoss = 0;

      portfolio.forEach((coin, index) => {
        const mainCrypto = cryptoData.find(c => c.id === coin.id);
        const currentPrice = mainCrypto ? mainCrypto.current_price : 0;
        const currentValue = coin.amount * currentPrice;
        const profitLoss = currentValue - coin.invested;
        const profitLossPercentage = (profitLoss / coin.invested) * 100;

        totalInvested += coin.invested;
        totalPortfolioValue += currentValue;
        totalProfitLoss += profitLoss;

        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${coin.name} (${coin.symbol.toUpperCase()})</td>
          <td>${coin.amount}</td>
          <td>$${coin.buyPrice.toFixed(2)}</td>
          <td>$${coin.invested.toFixed(2)}</td>
          <td>${coin.date}</td>
          <td>$${currentPrice.toFixed(2)}</td>
          <td>$${currentValue.toFixed(2)}</td>
          <td class="${profitLoss >= 0 ? 'profit' : 'loss'}">
            $${profitLoss.toFixed(2)} (${profitLossPercentage.toFixed(2)}%)
          </td>
          <td>
            <i class="fas fa-edit edit-btn-portfolio" data-index="${index}"></i>
            <i class="fas fa-trash-alt delete-btn-portfolio" data-index="${index}"></i>
          </td>
        `;
        tableBody.appendChild(row);
      });

      // Actualizar resumen del portafolio
      totalInvestedPortfolio.textContent = `$${totalInvested.toFixed(2)}`;
      totalPortfolioValuePortfolio.textContent = `$${totalPortfolioValue.toFixed(2)}`;
      totalProfitLossPortfolio.textContent = `$${totalProfitLoss.toFixed(2)} (${totalProfitLoss !== 0 ? (totalProfitLoss > 0 ? '+' : '') + (totalProfitLoss / totalInvested * 100).toFixed(2) + '%' : '0%'})`;
      totalProfitLossPortfolio.className = totalProfitLoss >= 0 ? 'summary-value' : 'summary-value loss';
      lastPortfolioUpdate.textContent = `Última actualización: ${new Date().toLocaleString()}`; // Actualizar la fecha y hora de la última actualización

      attachPortfolioEventListeners();

      // Guardar cambios en el almacenamiento local
      localStorage.setItem('portfolio', JSON.stringify(portfolio));
    }

    function attachPortfolioEventListeners() {
      $('.edit-btn-portfolio').off('click').on('click', function() {
        const index = $(this).data('index');
        const coin = portfolio[index];

        // Auto-llenar el formulario con los datos de la criptomoneda seleccionada
        portfolioCryptoName.value = coin.id;
        portfolioCryptoSymbol.value = coin.symbol.toUpperCase();
        portfolioCryptoAmount.value = coin.amount;
        portfolioCryptoBuyPrice.value = coin.buyPrice;
        portfolioCryptoDate.value = coin.date;

        // Remover la criptomoneda del portafolio para actualizarla
        portfolio.splice(index, 1);
        updatePortfolioTable();
      });

      $('.delete-btn-portfolio').off('click').on('click', function() {
        const index = $(this).data('index');
        portfolio.splice(index, 1);
        updatePortfolioTable();
      });
    }

    // Manejar la adición de criptomonedas al portafolio
    async function handleAddPortfolioCrypto(e) {
      e.preventDefault();
      const selectedCoinId = portfolioCryptoName.value;
      const cryptoSymbol = portfolioCryptoSymbol.value;
      const amount = parseFloat(portfolioCryptoAmount.value);
      const buyPrice = parseFloat(portfolioCryptoBuyPrice.value);
      const date = portfolioCryptoDate.value;

      if (!selectedCoinId || !cryptoSymbol || isNaN(amount) || isNaN(buyPrice) || !date) {
        alert("Por favor, completa todos los campos correctamente.");
        return;
      }

      // Obtener el nombre de la criptomoneda desde cryptoData
      const crypto = cryptoData.find(c => c.id === selectedCoinId);
      const cryptoName = crypto ? crypto.name : '';

      // Calcular el valor invertido
      const invested = amount * buyPrice;

      // Añadir al portafolio
      const newPortfolioCoin = {
        id: selectedCoinId,
        name: cryptoName,
        symbol: cryptoSymbol,
        amount: amount,
        buyPrice: buyPrice,
        invested: invested,
        date: date
      };

      portfolio.push(newPortfolioCoin);
      localStorage.setItem('portfolio', JSON.stringify(portfolio));
      updatePortfolioTable();

      // Limpiar el formulario
      addPortfolioForm.reset();
    }

    // Auto-llenar el símbolo basado en la criptomoneda seleccionada
    function autoFillPortfolioSymbol() {
      const selectedCoinId = portfolioCryptoName.value;
      const crypto = cryptoData.find(c => c.id === selectedCoinId);
      if (crypto) {
        portfolioCryptoSymbol.value = crypto.symbol.toUpperCase();
      } else {
        portfolioCryptoSymbol.value = '';
      }
    }

    // Función para actualizar los precios actuales en el portafolio
    function updatePortfolioPrices() {
      const startTime = performance.now();
      updatePortfolioTable();
      const endTime = performance.now();
      const timeTaken = endTime - startTime;
      updateTimePortfolio.textContent = `Tiempo de actualización: ${timeTaken.toFixed(2)} ms`;
      lastPortfolioUpdate.textContent = `Última actualización: ${new Date().toLocaleString()}`;
      speakMessage("Precios del portafolio actualizados.");
    }

    // === 27) Función para Comparar Criptomonedas ===
    // Ya implementada arriba

    // === 28) Función para Cerrar el Modal de Comparación ===
    // Ya implementada arriba

    // === 29) Función para Abrir el Modal de Comparación ===
    // Ya implementada arriba

    // === 30) Botón "Ver Análisis" en el Modal de Comparación ===
    // Ya implementada arriba

    // === 31) Botón "Volver" en el Modal de Comparación ===
    // Ya implementada arriba

    // === 32) Función de Filtros ===
    // Ya implementada arriba

    // === 34) Funciones para el Modal de Portafolio ===
    // Ya implementada arriba

    // === Otras Funciones ===
    // ... (Mantener todas las otras funciones existentes)

    // === Funciones adicionales para nuevos indicadores ===

    // Función simulada para calcular On-Balance Volume (OBV)
    function calculateOBV(coinData) {
      // CoinGecko no proporciona OBV directamente. Normalmente, se calcula a partir de los precios y volúmenes históricos.
      // Aquí simulamos un valor.
      return Math.floor(Math.random() * 1000000).toLocaleString();
    }

    // Función simulada para obtener Sentimiento del Mercado
    function getMarketSentiment() {
      const sentiments = ['Positivo', 'Neutral', 'Negativo'];
      return sentiments[Math.floor(Math.random() * sentiments.length)];
    }

    // Función simulada para obtener Número de Transacciones Diarias
    function getDailyTransactions() {
      // CoinGecko no proporciona este dato directamente. Simulamos un valor.
      return Math.floor(Math.random() * 10000).toLocaleString();
    }

    // === Función para Simular RSI Basado en Variación de Precio ===
    function simulateRSI(priceChangePercentage) {
      if (priceChangePercentage === null || isNaN(priceChangePercentage)) return null;
      // Simplemente mapea el cambio de precio a un RSI simulado
      if (priceChangePercentage > 5) return 80; // Alto RSI
      if (priceChangePercentage < -5) return 20; // Bajo RSI
      return 50; // RSI neutral
    }

    // === Implementar lógica para habilitar el botón "Comparar" cuando se seleccionan dos criptomonedas ===
    function checkCompareButtonState() {
      if (compareCrypto1Select.value && compareCrypto2Select.value && compareCrypto1Select.value !== compareCrypto2Select.value) {
        compareBtn.classList.add('enabled');
        compareBtn.disabled = false;
      } else {
        compareBtn.classList.remove('enabled');
        compareBtn.disabled = true;
      }
    }

    // === 34) Funciones para Reutilizar en el Modal de Portafolio ===
    // Ya implementada arriba

    // === Iniciar ===
    initialize();

    // === 34) Funciones para Reutilizar en el Modal de Portafolio ===
    // Ya implementada arriba

    // === 34) Funciones para Reutilizar en el Modal de Portafolio ===
    // Ya implementada arriba
  </script>
</body>
</html>
