<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Monitor Criptomonedas - RSI + PnL + Voz + Favoritas Primero</title>
  <style>
    /* Estilos generales */
    body.dark {
      background-color: #0a0e17;
      color: #ffffff;
    }
    body.light {
      background-color: #f0f0f0;
      color: #000000;
    }
    body {
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 20px;
      transition: background-color 0.3s, color 0.3s;
    }
    h1 {
      text-align: center;
      color: #00ffcc;
      font-size: 2.5em;
      margin-bottom: 5px;
    }
    h3 {
      text-align: center;
      color: #7a8599;
      margin-top: -10px;
      font-size: 0.9em;
      font-weight: normal;
    }
    #indicatorExplanation {
      max-width: 800px;
      margin: 10px auto 20px auto;
      background-color: #1a2332;
      border-radius: 10px;
      padding: 15px;
      color: #ccc;
      font-size: 0.9em;
    }
    body.light #indicatorExplanation {
      background-color: #eaeaea;
      color: #333;
    }
    #indicatorExplanation p {
      margin: 5px 0;
      line-height: 1.3em;
    }
    #lastUpdate {
      text-align: center;
      margin-top: 5px;
      font-style: italic;
      color: #7a8599;
      margin-bottom: 20px;
    }
    #filtersContainer {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    #coinFilterContainer,
    #rsiFilterContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #1a2332;
      border-radius: 15px;
      padding: 10px;
    }
    body.light #coinFilterContainer,
    body.light #rsiFilterContainer {
      background-color: #eaeaea;
    }
    label {
      margin-bottom: 5px;
      font-weight: bold;
    }
    select {
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: transparent;
      color: inherit;
    }
    #coinFilter {
      background-color: #0a0e17;
      color: #ffffff;
      border: 1px solid #00ffcc;
      border-radius: 10px;
      padding: 10px;
      min-width: 150px;
    }

    #rsiFilter {
      background-color: #0a0e17;
      color: #ffffff;
      border: 1px solid #00ffcc;
      border-radius: 10px;
      padding: 10px;
      min-width: 150px;
    }

    #intervalContainer {
      text-align: center;
      margin-top: 10px;
      margin-bottom: 20px;
    }
    #intervalContainer label {
      margin-right: 5px;
    }
    #updateIntervalInput {
      width: 60px;
      padding: 5px;
      border-radius: 5px;
      border: none;
    }
    #setIntervalBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #00ffcc;
      color: #0a0e17;
      cursor: pointer;
    }

    #cryptoGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }
    .crypto-card {
      background-color: #1a2332;
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
      cursor: pointer;
      position: relative;
    }
    body.light .crypto-card {
      background-color: #ffffff;
      color: #000000;
    }
    .crypto-card:hover {
      transform: translateY(-5px);
    }
    .crypto-card:hover::after {
      content: "Doble clic para ver gr√°fico";
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #00ffcc;
      color: #0a0e17;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      white-space: nowrap;
    }
    .crypto-logo {
      width: 60px;
      height: 60px;
      margin-bottom: 15px;
    }
    .crypto-name {
      font-size: 1.2em;
      font-weight: bold;
      margin-bottom: 10px;
      word-break: break-word;
    }
    .crypto-price {
      font-size: 1.1em;
      margin-bottom: 15px;
    }
    .flag {
      display: inline-block;
      padding: 8px 15px;
      border-radius: 20px;
      font-weight: bold;
      text-transform: uppercase;
      font-size: 0.9em;
      white-space: nowrap;
    }
    .green-flag {
      background-color: #4CAF50;
      color: white;
    }
    .red-flag {
      background-color: #F44336;
      color: white;
    }
    .neutral-flag {
      background-color: #FF9800;
      color: white;
    }
    .mini-chart-container {
      margin-top: 15px;
      position: relative;
      height: 80px;
    }
    canvas.mini-chart {
      width: 100%;
      height: 100%;
    }
    .no-chart-text {
      margin-top: 15px;
      font-size: 0.8em;
      color: #7a8599;
    }
    .favorite-icon {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: 1.2em;
      color: #ffc107;
    }
    #error {
      text-align: center;
      color: #F44336;
      font-size: 1.2em;
      margin-top: 50px;
      display: none;
    }
    #modalOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      padding: 0;
    }
    #modalContent {
      background: #1a2332;
      border-radius: 15px;
      width: 95vw;
      height: 95vh;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding: 20px;
    }
    body.light #modalContent {
      background: #f0f0f0;
      color: #000000;
    }
    #modalClose {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #00ffcc;
      color: #0a0e17;
      border: none;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
      padding: 10px;
      border-radius: 5px;
    }
    #chartContainer {
      width: 100%;
      min-height: 300px;
      margin-bottom: 20px;
      position: relative;
    }
    #cryptoChart {
      width: 100%;
      height: 100%;
    }
    .modal-footer {
      font-size: 0.9em;
      color: #7a8599;
      text-align: center;
      word-break: break-all;
      margin-top: 20px;
    }
    body.light .modal-footer {
      color: #333333;
    }
    .modal-info {
      text-align: center;
      margin-bottom: 10px;
    }
    .modal-info p {
      margin: 5px 0;
    }
    .modal-explanation {
      font-size: 0.9em;
      margin-top: 15px;
      background-color: #0a0e17;
      padding: 10px;
      border-radius: 10px;
    }
    body.light .modal-explanation {
      background-color: #ddd;
      color: #000;
    }
    .modal-explanation h4 {
      margin-top: 10px;
      margin-bottom: 5px;
    }
    #priceAlertContainer {
      margin: 10px 0;
      text-align: center;
    }
    #percentAlertLabel {
      display: inline-block;
      margin-right: 5px;
    }
    #priceAlertInput {
      width: 60px;
      padding: 5px;
      border-radius: 5px;
      border: none;
    }
    #setAlertBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #00ffcc;
      color: #0a0e17;
      cursor: pointer;
    }
    #buyPriceContainer {
      margin: 10px 0;
      text-align: center;
    }
    #buyPriceInput {
      width: 100px;
      padding: 5px;
      border-radius: 5px;
      border: none;
    }
    #setBuyPriceBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #00ffcc;
      color: #0a0e17;
      cursor: pointer;
    }
    #clearBuyPriceBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #F44336;
      color: white;
      cursor: pointer;
    }
    #profitLossContainer {
      margin: 10px 0;
      text-align: center;
    }
    #profitLossText {
      margin: 5px;
      font-weight: bold;
    }
    .green-arrow {
      color: #00ff00;
      font-weight: bold;
    }
    .red-arrow {
      color: #ff4444;
      font-weight: bold;
    }
    #themeToggle {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background-color: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 0.8em;
      z-index: 2000;
    }
    #favoritesBar {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 5px;
      z-index: 1000;
    }
    #btnFavoritos, #btnVerTodos {
      background-color: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 8px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 0.8em;
    }
    #updateChartBtn {
      background: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px auto 5px auto;
      display: block;
      font-size: 0.9em;
    }
    #lastUpdateModal {
      text-align: center;
      font-style: italic;
      color: #7a8599;
      margin-top: 5px;
      margin-bottom: 10px;
    }
    #verAnalisisBtn {
      background: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px auto 0 auto;
      display: block;
      font-size: 0.9em;
    }
    #silenciarAlertasBtn {
      background: #FF9800;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      cursor: pointer;
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 2100;
    }
    /* Estilos para la barra de progreso */
    #progressOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 4000;
      flex-direction: column;
      color: #ffffff;
      font-size: 1.2em;
      flex-wrap: wrap;
    }
    #progressBarContainer {
      width: 80%;
      background-color: #ddd;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 20px;
    }
    #progressBar {
      width: 0%;
      height: 30px;
      background-color: #00ffcc;
      transition: width 0.3s;
    }
    @media (max-width: 768px) {
      #modalContent {
        width: 98vw;
        height: 98vh;
      }
      #progressBarContainer {
        width: 90%;
      }
    }
  </style>
</head>
<body class="dark">
  <h1>Monitor Criptomonedas</h1>
  <h3>by Pablo Bascoy</h3>

  <!-- Barra de progreso -->
  <div id="progressOverlay">
    <div id="progressMessage">Cargando criptomonedas...</div>
    <div id="progressBarContainer">
      <div id="progressBar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>

  <!-- Explicaci√≥n de RSI -->
  <div id="indicatorExplanation">
    <p><strong>¬øQu√© es el RSI (Relative Strength Index)?</strong></p>
    <p>El RSI mide la fortaleza o debilidad de un activo seg√∫n sus √∫ltimos movimientos de precio, entre 0 y 100.</p>
    <ul>
      <li>RSI &gt; 70: Se√±al de venta.</li>
      <li>RSI &lt; 30: Se√±al de compra.</li>
      <li>RSI 30-70: Fase neutra.</li>
    </ul>
    <p>Las criptomonedas marcadas como favoritas aparecer√°n primero cada vez que se actualice (autom√°tico o manual).  
    Puedes actualizar manualmente o cada cierto n√∫mero de segundos. El % de ganancia/p√©rdida se recalcula seg√∫n tu precio de compra.</p>
  </div>

  <p id="lastUpdate">√öltima actualizaci√≥n: (sin datos)</p>

  <div id="intervalContainer">
    <label>Actualizaci√≥n (segundos):
      <input type="number" id="updateIntervalInput" placeholder="30">
    </label>
    <button id="setIntervalBtn">Set Interval</button>
  </div>

  <div id="filtersContainer">
    <div id="coinFilterContainer">
      <label for="coinFilter">Criptomoneda</label>
      <select id="coinFilter">
          <option value="all">Todas</option>
      </select>
    </div>
    <div id="rsiFilterContainer">
      <label for="rsiFilter">Estado RSI</label>
      <select id="rsiFilter">
          <option value="all">Todas</option>
          <option value="comprar">Comprar</option>
          <option value="vender">Vender</option>
          <option value="esperar">Esperar</option>
          <option value="neutral">Neutral</option>
      </select>
    </div>
  </div>

  <div id="error">No se pudo acceder a los datos en tiempo real. Por favor, intente m√°s tarde.</div>
  <div id="cryptoGrid"></div>

  <div id="modalOverlay">
    <div id="modalContent">
      <button id="modalClose">Regresar</button>
      <h2 id="modalTitle"></h2>
      <button id="updateChartBtn">Actualizar</button>
      <p id="lastUpdateModal"></p>
      <div class="modal-info" id="modalInfo"></div>
      <div id="chartContainer">
        <canvas id="cryptoChart"></canvas>
      </div>
      <button id="verAnalisisBtn">Ver An√°lisis</button>

      <div id="priceAlertContainer">
        <label id="percentAlertLabel">% de ganancia para alerta:
          <input type="number" id="priceAlertInput" placeholder="5">
        </label>
        <button id="setAlertBtn">Set Alert</button>
      </div>

      <div id="buyPriceContainer">
        <label>Precio de Compra: $<input type="number" id="buyPriceInput" placeholder="0.00"></label>
        <button id="setBuyPriceBtn">Colocar precio de compra</button>
        <button id="clearBuyPriceBtn">Borrar precio de compra</button>
      </div>
      <div id="profitLossContainer">
        <p id="profitLossText">Ganancia/Perdida: 0%</p>
      </div>

      <div class="modal-explanation">
        <h4>Explicaci√≥n de los Indicadores:</h4>
        <p><span style="color:#00ffcc;font-weight:bold;">L√≠nea principal (cyan):</span> Representa el <strong>precio hist√≥rico</strong> de la criptomoneda durante el per√≠odo analizado.</p>
        <p><span style="color:#4CAF50;font-weight:bold;">L√≠nea de tendencia (verde/punteada):</span> Indica la <strong>tendencia actual</strong> del precio, ayudando a identificar si el precio est√° en alza, baja o en una fase lateral.</p>
        <p><span style="color:#FFD700;font-weight:bold;">SMA (7) (amarillo):</span> Es la <strong>Media M√≥vil Simple de 7 periodos</strong>, que suaviza las fluctuaciones de precio a corto plazo para identificar tendencias recientes.</p>
        <p><span style="color:#FF8C00;font-weight:bold;">SMA (30) (naranja):</span> Es la <strong>Media M√≥vil Simple de 30 periodos</strong>, que proporciona una visi√≥n de las tendencias a mediano plazo.</p>
        <p><span style="color:#00BFFF;font-weight:bold;">Volumen (azul):</span> Muestra la <strong>cantidad de operaciones</strong> realizadas durante cada periodo, lo que puede indicar la fuerza detr√°s de los movimientos de precio.</p>
        <p><span style="color:#EE82EE;font-weight:bold;">L√≠nea IA (violeta):</span> Representa la <strong>predicci√≥n de inteligencia artificial</strong>, proyectando posibles movimientos futuros del precio basados en patrones hist√≥ricos.</p>
        <h4>Consejo:</h4>
        <p id="adviceText">(Se llenar√° con consejos aleatorios)</p>
      </div>

      <div class="modal-footer">
        <span id="dataSource"></span>
      </div>
    </div>
  </div>

  <button id="themeToggle">Tema</button>
  <div id="favoritesBar">
    <button id="btnFavoritos">Favoritos</button>
    <button id="btnVerTodos">Ver Todos</button>
  </div>

  <button id="silenciarAlertasBtn">Silenciar Alertas</button>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <script>
    let chartInstance = null;
    let cryptoData = [];
    let favorites = JSON.parse(localStorage.getItem('favorites')) || [];
    let priceAlerts = JSON.parse(localStorage.getItem('priceAlerts')) || {};
    let buyPrices = JSON.parse(localStorage.getItem('buyPrices')) || {};
    let currentModalCoinId = null;
    let currentModalCoinName = null;
    let currentModalPrice = null;
    let currentModalSymbol = null;
    let silenciarAlertas = false;
    let updateTimer = null;
    let favoritesActive = false; // Flag para controlar el filtro de favoritos

    // Intervalo por defecto 30 seg
    let updateInterval = parseInt(localStorage.getItem('updateInterval')) || 30;

    const body = document.body;
    const themeToggle = document.getElementById('themeToggle');
    const silenciarAlertasBtn = document.getElementById('silenciarAlertasBtn');
    const lastUpdateElement = document.getElementById('lastUpdate');
    const errorElement = document.getElementById('error');
    const cryptoGrid = document.getElementById('cryptoGrid');
    const coinFilter = document.getElementById('coinFilter');
    const rsiFilter = document.getElementById('rsiFilter');
    const modalOverlay = document.getElementById('modalOverlay');
    const modalClose = document.getElementById('modalClose');
    const modalTitle = document.getElementById('modalTitle');
    const dataSource = document.getElementById('dataSource');
    const modalInfo = document.getElementById('modalInfo');
    const adviceText = document.getElementById('adviceText');
    const verAnalisisBtn = document.getElementById('verAnalisisBtn');
    const lastUpdateModal = document.getElementById('lastUpdateModal');
    const priceAlertInput = document.getElementById('priceAlertInput');
    const setAlertBtn = document.getElementById('setAlertBtn');
    const buyPriceInput = document.getElementById('buyPriceInput');
    const setBuyPriceBtn = document.getElementById('setBuyPriceBtn');
    const clearBuyPriceBtn = document.getElementById('clearBuyPriceBtn');
    const profitLossText = document.getElementById('profitLossText');
    const btnFavoritos = document.getElementById('btnFavoritos');
    const btnVerTodos = document.getElementById('btnVerTodos');
    const updateChartBtn = document.getElementById('updateChartBtn');
    const updateIntervalInputElem = document.getElementById('updateIntervalInput');
    const setIntervalBtnElem = document.getElementById('setIntervalBtn');

    // Barra de progreso
    const progressOverlay = document.getElementById('progressOverlay');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const progressMessage = document.getElementById('progressMessage');

    // Tema
    const savedTheme = localStorage.getItem('theme') || 'dark';
    body.className = savedTheme;

    themeToggle.addEventListener('click', () => {
      body.className = (body.className === 'dark') ? 'light' : 'dark';
      localStorage.setItem('theme', body.className);
      // Actualizar colores de los gr√°ficos si est√°n abiertos
      if (chartInstance) {
        chartInstance.options.scales.y.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y1.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.x.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y1.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.plugins.legend.labels.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.update();
      }
    });

    // Bot√≥n silenciar
    silenciarAlertasBtn.addEventListener('click', () => {
      silenciarAlertas = !silenciarAlertas;
      silenciarAlertasBtn.textContent = silenciarAlertas ? "Activar Alertas" : "Silenciar Alertas";
    });

    // Intervalo configurable
    updateIntervalInputElem.value = updateInterval;
    setIntervalBtnElem.addEventListener('click', () => {
      const newVal = parseInt(updateIntervalInputElem.value);
      if (!isNaN(newVal) && newVal > 0) {
        updateInterval = newVal;
        localStorage.setItem('updateInterval', updateInterval);
        speakMessage(`Intervalo de actualizaci√≥n configurado a ${updateInterval} segundos.`);
        if (updateTimer) clearInterval(updateTimer);
        startUpdateTimer();
      }
    });

    // RSI
    function calculateRSI(closePrices, period = 14) {
      if (closePrices.length < period) return null;
      let gains = 0;
      let losses = 0;
      for (let i = 1; i < period; i++) {
        const diff = closePrices[i] - closePrices[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      let avgGain = gains / (period - 1);
      let avgLoss = losses / (period - 1);

      let rsiArray = [null];
      for (let i = period; i < closePrices.length; i++) {
        const diff = closePrices[i] - closePrices[i - 1];
        const gain = diff > 0 ? diff : 0;
        const loss = diff < 0 ? -diff : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;

        if (avgLoss === 0) {
          rsiArray.push(100);
        } else {
          const rs = avgGain / avgLoss;
          rsiArray.push(100 - (100 / (1 + rs)));
        }
      }
      return rsiArray[rsiArray.length - 1];
    }

    function getRecommendationFromRSI(rsiValue) {
      if (rsiValue === null) {
        return { flag: 'neutral-flag', text: 'Neutral (Sin RSI)', state: 'neutral' };
      }
      if (rsiValue > 70) {
        return { flag: 'red-flag', text: 'Vender (RSI>70)', state: 'vender' };
      } else if (rsiValue < 30) {
        return { flag: 'green-flag', text: 'Comprar (RSI<30)', state: 'comprar' };
      } else if (rsiValue >= 30 && rsiValue <= 70) {
        return { flag: 'neutral-flag', text: 'Esperar (RSI 30-70)', state: 'esperar' };
      } else {
        return { flag: 'neutral-flag', text: 'Neutral (Sin RSI)', state: 'neutral' };
      }
    }

    // Voz
    function speakMessage(text) {
      if (silenciarAlertas) return;
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'es-ES';
        utterance.rate = 1;
        utterance.pitch = 1;
        speechSynthesis.speak(utterance);
      }
    }

    // Creaci√≥n y actualizaci√≥n de cards
    function createCryptoCard(crypto, index, rsiRecommendation) {
      const card = document.createElement('div');
      card.className = 'crypto-card';
      card.setAttribute('data-coin-id', crypto.id);
      card.setAttribute('data-coin-name', crypto.name);
      card.setAttribute('data-current-price', crypto.current_price);
      card.setAttribute('data-rsi-state', rsiRecommendation.state); // Asegurarse que es en min√∫sculas

      const isFav = favorites.includes(crypto.id);
      const star = isFav ? '‚òÖ' : '‚òÜ';

      card.innerHTML = `
        <div class="favorite-icon">${star}</div>
        <img src="${crypto.image}" alt="${crypto.name} logo" class="crypto-logo">
        <div class="crypto-name">${crypto.name}</div>
        <div class="crypto-price">$${crypto.current_price.toFixed(2)}</div>
        <div class="flag ${rsiRecommendation.flag}">${rsiRecommendation.text}</div>
        <div class="mini-chart-container">
          <canvas id="miniChart-${index}" class="mini-chart"></canvas>
        </div>
      `;

      // Favorito
      const favIcon = card.querySelector('.favorite-icon');
      favIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleFavorite(crypto.id, card);
      });

      // Doble click / double tap
      let lastTap = 0;
      card.addEventListener('dblclick', () => {
        openModal(crypto.id, crypto.name, crypto.current_price, crypto.symbol.toUpperCase() + 'USDT');
      });
      card.addEventListener('touchend', (event) => {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        if (tapLength < 300 && tapLength > 0) {
          openModal(crypto.id, crypto.name, crypto.current_price, crypto.symbol.toUpperCase() + 'USDT');
          event.preventDefault();
        }
        lastTap = currentTime;
      });

      return card;
    }

    function toggleFavorite(coinId, card) {
      if (favorites.includes(coinId)) {
        favorites = favorites.filter(f => f !== coinId);
        card.querySelector('.favorite-icon').textContent = '‚òÜ';
      } else {
        favorites.push(coinId);
        card.querySelector('.favorite-icon').textContent = '‚òÖ';
      }
      localStorage.setItem('favorites', JSON.stringify(favorites));
      reorderCards();
      if (favoritesActive) {
        applyFilters(); // Reaplicar filtros si est√° activo
      }
    }

    /**
     * Reordena para que las favoritas vayan siempre primero.
     */
    function reorderCards() {
      const cards = Array.from(document.querySelectorAll('.crypto-card'));
      const favCards = [];
      const otherCards = [];

      cards.forEach(card => {
        const coinId = card.getAttribute('data-coin-id');
        if (favorites.includes(coinId)) {
          favCards.push(card);
        } else {
          otherCards.push(card);
        }
      });

      cryptoGrid.innerHTML = '';
      // Primero favoritas
      favCards.forEach(c => cryptoGrid.appendChild(c));
      // Luego las dem√°s
      otherCards.forEach(c => cryptoGrid.appendChild(c));
    }

    async function loadMiniChart(binanceSymbol, index) {
      try {
        const endpoint = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=1m&limit=30`;
        const res = await fetch(endpoint, {cache:'no-store'});
        if (!res.ok) return false;
        const klineData = await res.json();
        if (!Array.isArray(klineData) || klineData.length === 0) return false;

        const closePrices = klineData.map(c => parseFloat(c[4]));
        const labels = klineData.map(c => {
          const date = new Date(c[0]);
          return `${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
        });

        const miniCtx = document.getElementById(`miniChart-${index}`);
        if (!miniCtx) return false;
        const miniChartCtx = miniCtx.getContext('2d');
        new Chart(miniChartCtx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              data: closePrices,
              borderColor: '#00ffcc',
              backgroundColor: 'rgba(0,255,204,0.1)',
              tension: 0.3,
              fill: true,
              pointRadius: 0
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { display: false },
              y: { display: false }
            },
            plugins: {
              legend: { display: false }
            }
          }
        });
        return true;
      } catch (e) {
        return false;
      }
    }

    // PnL
    function updateProfitLoss(coinId, currentPrice) {
      const buy = parseFloat(buyPrices[coinId] || 0);
      if (!isNaN(buy) && buy > 0) {
        const pnl = ((currentPrice - buy) / buy) * 100;
        let arrow = '';
        if (pnl > 0) {
          arrow = '<span class="green-arrow">‚ñ≤</span>';
        } else if (pnl < 0) {
          arrow = '<span class="red-arrow">‚ñº</span>';
        }
        profitLossText.innerHTML = `Ganancia/Perdida: ${pnl.toFixed(2)}% ${arrow}`;
      } else {
        profitLossText.textContent = `Ganancia/Perdida: 0%`;
      }
    }

    async function fetchCryptoData(forceUpdate = false) {
      try {
        // Mostrar barra de progreso y desactivar interacciones
        progressOverlay.style.display = 'flex';
        cryptoGrid.innerHTML = '';
        coinFilter.innerHTML = '<option value="all">Todas</option>';
        rsiFilter.value = 'all'; // Reset RSI filter
        btnFavoritos.disabled = true;
        btnVerTodos.disabled = true;
        coinFilter.disabled = true;
        rsiFilter.disabled = true;

        const response = await fetch(
          'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=50&page=1&sparkline=false',
          { cache: 'no-store' }
        );
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error("No se obtuvieron datos de CoinGecko.");
        }
        cryptoData = data;

        const totalCryptos = data.length;
        let loadedCryptos = 0;

        // Limpiar cryptoGrid y reiniciar filtros
        cryptoGrid.innerHTML = '';
        coinFilter.innerHTML = '<option value="all">Todas</option>';

        for (let coin of data) {
          await createCardWithRSI(coin, loadedCryptos, totalCryptos);
          loadedCryptos++;
          const progressPercentage = Math.round((loadedCryptos / totalCryptos) * 100);
          progressBar.style.width = `${progressPercentage}%`;
          progressText.textContent = `${progressPercentage}%`;
          progressMessage.textContent = `Cargando ${loadedCryptos} de ${totalCryptos} criptomonedas...`;
        }

        // Reordenamos (favoritas primero)
        reorderCards();

        lastUpdateElement.textContent = `√öltima actualizaci√≥n: ${new Date().toLocaleString()}`;

        // Recalcular PnL
        for (const coin of data) {
          if (buyPrices[coin.id]) {
            const card = document.querySelector(`.crypto-card[data-coin-id="${coin.id}"]`);
            if (card) {
              card.setAttribute('data-current-price', coin.current_price);
              if (coin.id === currentModalCoinId) {
                updateProfitLoss(coin.id, coin.current_price);
              }
            }
          }
        }

        applyFilters(); // Aplicar filtros despu√©s de cargar los datos

        // Ocultar barra de progreso y habilitar interacciones
        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;

      } catch (error) {
        console.error('Error al obtener datos:', error);
        errorElement.style.display = 'block';
        errorElement.textContent = 'No se pudo acceder a los datos en tiempo real. Por favor, intente m√°s tarde.';
        // Ocultar barra de progreso y habilitar interacciones
        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      }
    }

    async function createCardWithRSI(crypto, loadedCryptos, totalCryptos) {
      const binanceSymbol = (crypto.symbol.toUpperCase() + 'USDT');
      let rsiValue = null;
      try {
        const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=1m&limit=30`, { cache: 'no-store' });
        if (res.ok) {
          const klineData = await res.json();
          const closePrices = klineData.map(c => parseFloat(c[4]));
          if (closePrices.length > 0) {
            rsiValue = calculateRSI(closePrices, 14);
          }
        }
      } catch (err) {
        // Manejo silencioso de errores de fetch de Binance
      }
      const rsiRec = getRecommendationFromRSI(rsiValue);

      // Alertas de voz
      if (!silenciarAlertas && favorites.includes(crypto.id) && rsiValue !== null) {
        const percentAlert = parseFloat(priceAlerts['globalPercentAlert'] || 5);

        // RSI vender
        if (rsiValue >= 70) {
          const buyVal = parseFloat(buyPrices[crypto.id] || 0);
          if (buyVal > 0) {
            const pnl = ((crypto.current_price - buyVal) / buyVal) * 100;
            if (pnl >= percentAlert) {
              speakMessage(`Se sugiere vender ${crypto.name}. Ganancia de ${pnl.toFixed(2)} porciento, RSI: ${rsiValue.toFixed(2)}`);
            }
          }
        }
        // RSI comprar
        else if (rsiValue < 30) {
          const buyVal = parseFloat(buyPrices[crypto.id] || 0);
          if (buyVal === 0) {
            speakMessage(`Se sugiere comprar ${crypto.name}. RSI: ${rsiValue.toFixed(2)}. Sin precio de compra configurado.`);
          }
        }
      }

      // Crear card
      const card = createCryptoCard(crypto, loadedCryptos, rsiRec);
      cryptoGrid.appendChild(card);

      // A√±adir option al select
      const opt = document.createElement('option');
      opt.value = crypto.id; // Usar ID para facilitar el filtrado
      opt.textContent = crypto.name;
      coinFilter.appendChild(opt);

      const loaded = await loadMiniChart(binanceSymbol, loadedCryptos);
      if (!loaded) {
        card.querySelector('.mini-chart-container').innerHTML = `<p class="no-chart-text">Sin datos de gr√°fico</p>`;
      }
    }

    async function openModal(coinId, coinName, currentPrice, binanceSymbol) {
      currentModalCoinId = coinId;
      currentModalCoinName = coinName;
      currentModalPrice = currentPrice;
      currentModalSymbol = binanceSymbol;
      await loadModalData(coinId, coinName, currentPrice, binanceSymbol);
    }

    async function loadModalData(coinId, coinName, currentPrice, binanceSymbol) {
      try {
        const endpoint = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=1m&limit=100`;
        const response = await fetch(endpoint, {cache:'no-store'});
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const klineData = await response.json();
        if (!Array.isArray(klineData) || klineData.length === 0) {
          throw new Error(`Sin datos para ${coinName}.`);
        }

        const closePrices = klineData.map(c => parseFloat(c[4]));
        const volumes = klineData.map(c => parseFloat(c[5]));
        const labels = klineData.map(c => {
          const date = new Date(c[0]);
          return `${date.getDate()}/${(date.getMonth()+1)} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
        });

        const lastPrice = closePrices[closePrices.length - 1];
        const trendValues = closePrices.map(() => lastPrice);

        const shortSMA = calculateSMA(closePrices, 7);
        const longSMA = calculateSMA(closePrices, 30);

        // CoinGecko
        const coingeckoDetails = await fetch(`https://api.coingecko.com/api/v3/coins/${coinId}`, {cache:'no-store'});
        const detailsData = await coingeckoDetails.json();
        const marketCap = detailsData.market_data?.market_cap?.usd || 'N/A';
        const volume24h = detailsData.market_data?.total_volume?.usd || 'N/A';

        const aiPredictions = generateAIPrediction(closePrices);
        const aiLabels = [];
        for (let i = 1; i <= aiPredictions.length; i++) {
          aiLabels.push(`Futuro+${i}`);
        }

        const rsiValue = calculateRSI(closePrices, 14);
        const rsiRec = getRecommendationFromRSI(rsiValue);
        const modalRecColor = (rsiRec.flag === 'green-flag') ? '#4CAF50'
                                : (rsiRec.flag === 'red-flag') ? '#F44336'
                                : '#FF9800';

        modalTitle.textContent = `${coinName} - Tendencia: ${rsiRec.text}`;
        dataSource.textContent = endpoint;

        modalInfo.innerHTML = `
          <p>Precio Actual: $${currentPrice.toFixed(2)}</p>
          <p>Market Cap: $${parseFloat(marketCap).toLocaleString()}</p>
          <p>Volumen 24h: $${parseFloat(volume24h).toLocaleString()}</p>
          <p>RSI (14): ${rsiValue ? rsiValue.toFixed(2) : 'N/A'}</p>
        `;

        modalOverlay.style.display = 'flex';

        if (chartInstance) {
          chartInstance.destroy();
        }

        // IA line
        const aiLine = Array(closePrices.length).fill(null).concat(aiPredictions);

        setTimeout(() => {
          chartInstance = new Chart(document.getElementById('cryptoChart').getContext('2d'), {
            data: {
              labels: labels.concat(aiLabels),
              datasets: [
                {
                  type: 'line',
                  label: `${coinName} (USD)`,
                  data: closePrices.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#00ffcc',
                  backgroundColor: 'rgba(0,255,204,0.1)',
                  tension: 0.3,
                  fill: true,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: `L√≠nea de tendencia (${rsiRec.text})`,
                  data: trendValues.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: modalRecColor,
                  borderDash: [5, 5],
                  pointRadius: 0,
                  fill: false,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: 'SMA (7)',
                  data: shortSMA.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#FFD700',
                  fill: false,
                  pointRadius: 0,
                  tension: 0.2,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: 'SMA (30)',
                  data: longSMA.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#FF8C00',
                  fill: false,
                  pointRadius: 0,
                  tension: 0.2,
                  yAxisID: 'y',
                },
                {
                  type: 'bar',
                  label: 'Volumen',
                  data: volumes.concat(Array(aiPredictions.length).fill(null)),
                  backgroundColor: 'rgba(0,191,255,0.3)',
                  borderColor: '#00BFFF',
                  borderWidth: 1,
                  yAxisID: 'y1'
                },
                {
                  type: 'line',
                  label: 'L√≠nea IA (Predicci√≥n)',
                  data: aiLine,
                  borderColor: '#EE82EE',
                  borderDash: [2, 2],
                  pointRadius: 0,
                  fill: false,
                  tension: 0.2,
                  yAxisID: 'y',
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              scales: {
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Precio (USD)',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Volumen',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  },
                  grid: {
                    drawOnChartArea: false,
                  },
                },
                x: {
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                }
              }
            }
          });
          chartInstance.update();
        }, 100);

        fillAdviceAndComments(detailsData);
        lastUpdateModal.textContent = `√öltima actualizaci√≥n: ${new Date().toLocaleString()}`;

        if (buyPrices[coinId]) {
          buyPriceInput.value = buyPrices[coinId];
        } else {
          buyPriceInput.value = "";
        }
        updateProfitLoss(coinId, currentPrice);

      } catch (error) {
        console.error('Error al mostrar modal con gr√°fico:', error);
        modalTitle.textContent = `${coinName} - Sin datos de gr√°fico`;
        modalInfo.innerHTML = `<p>No se pudieron obtener datos del gr√°fico. Intente m√°s tarde.</p>`;
        adviceText.textContent = "No hay suficientes datos para dar un consejo.";
        dataSource.textContent = "";
        modalOverlay.style.display = 'flex';
        lastUpdateModal.textContent = "";
      }
    }

    function fillAdviceAndComments(detailsData) {
      const randomAdvice = [
        "Observa tambi√©n el volumen para mayor precisi√≥n.",
        "Ten en cuenta la tendencia global del mercado.",
        "Considera noticias recientes que puedan afectar al activo.",
        "Combina RSI con otras medias m√≥viles para m√°s eficacia.",
        "Analiza la volatilidad antes de comprar o vender."
      ];
      adviceText.textContent = randomAdvice[Math.floor(Math.random() * randomAdvice.length)];
    }

    modalClose.addEventListener('click', () => {
      modalOverlay.style.display = 'none';
    });

    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) {
        modalOverlay.style.display = 'none';
      }
    });

    verAnalisisBtn.addEventListener('click', () => {
      // Como la secci√≥n de an√°lisis ha sido eliminada, deshabilitamos el bot√≥n
      // Alternativamente, podr√≠as redirigir a otra secci√≥n o eliminar el bot√≥n
      // Por ahora, lo mantendremos como est√°
      // Podr√≠as a√±adir una funci√≥n que muestre m√°s detalles si lo deseas
    });

    setAlertBtn.addEventListener('click', () => {
      const percentVal = parseFloat(priceAlertInput.value);
      if (!isNaN(percentVal) && percentVal > 0) {
        priceAlerts['globalPercentAlert'] = percentVal;
        localStorage.setItem('priceAlerts', JSON.stringify(priceAlerts));
        speakMessage(`Has establecido la alerta de ganancia en ${percentVal} porciento.`);
      }
    });

    setBuyPriceBtn.addEventListener('click', () => {
      if (currentModalCoinId && buyPriceInput.value) {
        const buyPrice = parseFloat(buyPriceInput.value);
        if (!isNaN(buyPrice) && buyPrice > 0) {
          buyPrices[currentModalCoinId] = buyPrice;
          localStorage.setItem('buyPrices', JSON.stringify(buyPrices));
          updateProfitLoss(currentModalCoinId, currentModalPrice);
          speakMessage(`Precio de compra establecido para ${currentModalCoinId} en ${buyPrice} d√≥lares.`);
        }
      }
    });

    clearBuyPriceBtn.addEventListener('click', () => {
      if (currentModalCoinId) {
        delete buyPrices[currentModalCoinId];
        localStorage.setItem('buyPrices', JSON.stringify(buyPrices));
        buyPriceInput.value = "";
        profitLossText.textContent = "Ganancia/Perdida: 0%";
      }
    });

    btnFavoritos.addEventListener('click', () => {
      favoritesActive = true;
      applyFilters();
    });

    btnVerTodos.addEventListener('click', () => {
      favoritesActive = false;
      resetFilters();
    });

    updateChartBtn.addEventListener('click', async () => {
      await fetchCryptoData(true);
      if (currentModalCoinId && currentModalCoinName && currentModalPrice && currentModalSymbol) {
        await loadModalData(currentModalCoinId, currentModalCoinName, currentModalPrice, currentModalSymbol);
      }
    });

    coinFilter.addEventListener('change', () => {
      applyFilters();
    });

    rsiFilter.addEventListener('change', () => {
      applyFilters();
    });

    // Primer fetch
    fetchCryptoData(false);

    // Timer
    function startUpdateTimer() {
      if (updateTimer) {
        clearInterval(updateTimer);
      }
      updateTimer = setInterval(async () => {
        await fetchCryptoData(true);
      }, updateInterval * 1000);
    }
    startUpdateTimer();

    // Funciones extra
    function calculateSMA(data, length) {
      const sma = [];
      for (let i = 0; i < data.length; i++) {
        if (i < length - 1) {
          sma.push(null);
        } else {
          const slice = data.slice(i - length + 1, i + 1);
          const sum = slice.reduce((a, b) => a + b, 0);
          sma.push(sum / length);
        }
      }
      return sma;
    }

    function generateAIPrediction(closePrices) {
      const predictions = [];
      const lastPrice = closePrices[closePrices.length - 1];
      for (let i = 1; i <= 10; i++) {
        const factor = 1 + (Math.random() - 0.5) * 0.02;
        predictions.push(lastPrice * factor);
      }
      return predictions;
    }

    function applyFilters() {
      const selectedCoin = coinFilter.value;
      const selectedRSI = rsiFilter.value;

      const cards = document.querySelectorAll('.crypto-card');
      cards.forEach(card => {
        let display = true;

        // Filtro de Favoritos
        if (favoritesActive) {
          const coinId = card.getAttribute('data-coin-id');
          if (!favorites.includes(coinId)) {
            display = false;
          }
        }

        // Filtro de Criptomoneda
        if (selectedCoin !== 'all') {
          const coinId = card.getAttribute('data-coin-id');
          if (coinId !== selectedCoin) {
            display = false;
          }
        }

        // Filtro de RSI
        if (selectedRSI !== 'all') {
          const rsiState = card.getAttribute('data-rsi-state');
          if (selectedRSI !== rsiState) {
            display = false;
          }
        }

        card.style.display = display ? 'block' : 'none';
      });

      // Reordenar despu√©s de aplicar filtros
      reorderCards();
    }

    function resetFilters() {
      coinFilter.value = 'all';
      rsiFilter.value = 'all';
      cryptoGrid.querySelectorAll('.crypto-card').forEach(card => {
        card.style.display = 'block';
      });
      reorderCards();
    }
  </script>
</body>
</html>
