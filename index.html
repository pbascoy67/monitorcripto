<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Monitor Criptomonedas - RSI + PnL + Voz + Favoritas Primero + Comparación</title>
  <style>
    /* === Estilos Generales === */
    body.dark {
      background-color: #0a0e17;
      color: #ffffff;
    }
    body.light {
      background-color: #f0f0f0;
      color: #000000;
    }
    body {
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 20px;
      transition: background-color 0.3s, color 0.3s;
    }
    h1 {
      text-align: center;
      color: #00ffcc;
      font-size: 2.5em;
      margin-bottom: 5px;
    }
    h3 {
      text-align: center;
      color: #7a8599;
      margin-top: -10px;
      font-size: 0.9em;
      font-weight: normal;
    }
    #indicatorExplanation {
      max-width: 800px;
      margin: 10px auto 20px auto;
      background-color: #1a2332;
      border-radius: 10px;
      padding: 15px;
      color: #ccc;
      font-size: 0.9em;
    }
    body.light #indicatorExplanation {
      background-color: #eaeaea;
      color: #333;
    }
    #indicatorExplanation p {
      margin: 5px 0;
      line-height: 1.3em;
    }
    #lastUpdate {
      text-align: center;
      margin-top: 5px;
      font-style: italic;
      color: #7a8599;
      margin-bottom: 20px;
    }
    /* === Contenedores de Filtros y Botones === */
    .top-bar {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-bottom: 20px;
      gap: 10px;
    }
    #favoritesBar {
      display: flex;
      gap: 5px;
    }
    #filtersContainer {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin: 0 auto 20px auto; /* Centrado horizontal */
      padding: 10px 20px;
      background-color: #1a2332;
      border-radius: 10px;
      width: fit-content;
    }
    body.light #filtersContainer {
      background-color: #eaeaea;
    }
    #filtersContainer select {
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: transparent;
      color: inherit;
      min-width: 150px;
      cursor: pointer;
    }
    /* === Estilos de Botones === */
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      font-size: 1em;
      cursor: pointer;
      transition: background-color 0.3s, opacity 0.3s;
      margin: 5px;
      color: #ffffff;
      display: inline-block;
      text-align: center;
      text-decoration: none;
    }
    .btn-primary {
      background-color: #00ffcc;
    }
    .btn-primary:hover {
      background-color: #00e6b8;
    }
    .btn-secondary {
      background-color: #FF9800;
    }
    .btn-secondary:hover {
      background-color: #e68900;
    }
    .btn-danger {
      background-color: #F44336;
    }
    .btn-danger:hover {
      background-color: #e31e26;
    }
    .btn-success {
      background-color: #4CAF50;
    }
    .btn-success:hover {
      background-color: #45a049;
    }
    .btn-warning {
      background-color: #FFEB3B;
      color: #000000;
    }
    .btn-warning:hover {
      background-color: #FDD835;
    }
    .btn-info {
      background-color: #2196F3;
    }
    .btn-info:hover {
      background-color: #1976D2;
    }
    .btn-default {
      background-color: #9E9E9E;
    }
    .btn-default:hover {
      background-color: #757575;
    }
    .btn.disabled,
    .btn:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }
    /* === Botón de Comparación en la Página Principal === */
    #compareCryptoBtn {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
    }
    /* === Grilla de Criptomonedas === */
    #cryptoGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }
    .crypto-card {
      background-color: #1a2332;
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
      cursor: pointer;
      position: relative;
    }
    body.light .crypto-card {
      background-color: #ffffff;
      color: #000000;
    }
    .crypto-card:hover {
      transform: translateY(-5px);
    }
    .crypto-card:hover::after {
      content: "Clic para ver gráfico";
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #00ffcc;
      color: #0a0e17;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      white-space: nowrap;
    }
    .crypto-logo {
      width: 60px;
      height: 60px;
      margin-bottom: 15px;
    }
    .crypto-name {
      font-size: 1.2em;
      font-weight: bold;
      margin-bottom: 10px;
      word-break: break-word;
    }
    .crypto-price {
      font-size: 1.1em;
      margin-bottom: 15px;
    }
    .flag {
      display: inline-block;
      padding: 8px 15px;
      border-radius: 20px;
      font-weight: bold;
      text-transform: uppercase;
      font-size: 0.9em;
      white-space: nowrap;
    }
    .green-flag {
      background-color: #4CAF50;
      color: white;
    }
    .red-flag {
      background-color: #F44336;
      color: white;
    }
    .neutral-flag {
      background-color: #FF9800;
      color: white;
    }
    .mini-chart-container {
      margin-top: 15px;
      position: relative;
      height: 80px;
    }
    canvas.mini-chart {
      width: 100%;
      height: 100%;
    }
    .no-chart-text {
      margin-top: 15px;
      font-size: 0.8em;
      color: #7a8599;
    }
    .favorite-icon {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: 1.2em;
      color: #ffc107;
    }
    
    /* === Modal Detallado === */
    #modalOverlay,
    #compareModalOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      padding: 0;
      overflow: hidden;
    }
    #modalContent,
    #compareModalContent {
      background: #1a2332;
      border-radius: 15px;
      width: 95vw;
      height: 95vh;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding: 20px;
      transition: width 0.3s, height 0.3s;
    }
    body.light #modalContent,
    body.light #compareModalContent {
      background-color: #ffffff;
      color: #000000;
    }
    .modalCloseBtn {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 5000;
    }
    #chartContainer,
    #comparisonChartContainer {
      width: 100%;
      min-height: 300px;
      margin-bottom: 20px;
      position: relative;
      transition: width 0.3s, height 0.3s; 
    }
    /* Clase expandida para móviles */
    #modalOverlay.expanded-view #modalContent,
    #compareModalOverlay.expanded-view #compareModalContent {
      width: 100vw;
      height: 100vh;
      border-radius: 0;
      flex-direction: column;
      padding: 0;
    }
    
    #modalOverlay.expanded-view #chartContainer,
    #compareModalOverlay.expanded-view #comparisonChartContainer {
      width: 100%;
      height: calc(100vh - 50px); /* Ajustar según los elementos del modal */
      flex-grow: 1;
    }
    
    /* Asegurar que el canvas del gráfico ocupe todo el contenedor */
    #cryptoChart,
    #comparisonChart {
      width: 100% !important;
      height: 100% !important;
    }
    
    /* Ocultar otros elementos del modal cuando está en vista expandida */
    #modalOverlay.expanded-view #modalContent > *:not(#chartContainer):not(#volverBtn),
    #compareModalOverlay.expanded-view #compareModalContent > *:not(#comparisonChartContainer):not(#volverCompareBtn) {
      display: none;
    }
    
    /* Estilos del botón "Regresar" */
    #volverBtn,
    #volverCompareBtn {
      /* Heredan estilos de .btn */
      /* Ya tienen clases específicas asignadas en HTML */
      display: none; /* Inicialmente oculto */
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 5000;
    }
    
    /* === Modal de Comparación === */
    #compareModalContent select {
      background-color: #000000;
      color: #ffffff;
    }
    body.light #compareModalContent select {
      background-color: #ffffff;
      color: #000000;
    }
    
    /* === Tabla Comparativa === */
    #comparisonTable {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }
    #comparisonTable th, #comparisonTable td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
      position: relative; /* Para el tooltip */
      cursor: default;
    }
    #comparisonTable th {
      background-color: #f2f2f2;
    }
    /* Tooltip Styles */
    .tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      white-space: nowrap;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s;
      z-index: 100;
      font-size: 0.8em;
    }
    #comparisonTable th:hover .tooltip,
    #comparisonTable td:hover .tooltip {
      opacity: 1;
      visibility: visible;
    }
    
    /* === Botones y Otros === */
    #themeToggle {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 2000;
    }
    #favoritesBar {
      display: flex;
      gap: 5px;
    }
    #btnFavoritos, #btnVerTodos {
      /* Heredan estilos de .btn */
      /* Ya tienen clases específicas asignadas en HTML */
    }
    #updateChartBtn {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
      margin: 10px auto 5px auto;
      display: block;
      font-size: 0.9em;
    }
    #lastUpdateModal {
      text-align: center;
      font-style: italic;
      color: #7a8599;
      margin-top: 5px;
      margin-bottom: 10px;
    }
    #verAnalisisBtn {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
      margin: 10px auto 0 auto;
      display: block;
      font-size: 0.9em;
    }
    #silenciarAlertasBtn {
      /* Hereda estilos de .btn */
      /* Ya tiene clases específicas asignadas en HTML */
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 2100;
    }
    
    /* === Barra de Progreso === */
    #progressOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 4000;
      flex-direction: column;
      color: #ffffff;
      font-size: 1.2em;
      flex-wrap: wrap;
    }
    #progressBarContainer {
      width: 80%;
      background-color: #ddd;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 20px;
    }
    #progressBar {
      width: 0%;
      height: 30px;
      background-color: #00ffcc;
      transition: width 0.3s;
    }
    @media (max-width: 768px) {
      #modalContent,
      #compareModalContent {
        width: 98vw;
        height: 98vh;
      }
      #progressBarContainer {
        width: 90%;
      }
      /* Ya movimos .expanded-chart fuera de la media query */
    }
    
    /* === Nuevos Estilos para Vista Expandida en el Modal === */
    /* Ya definidos arriba */
    
    /* === Nuevos Estilos para el Selector de Marco Temporal en el Modal === */
    #modalTimeFrameContainer {
      text-align: center;
      margin-bottom: 20px;
    }
    #modalTimeFrameContainer label {
      margin-right: 5px;
      font-weight: bold;
      cursor: help; /* Indica que hay información adicional */
    }
    #modalTimeFrameFilter {
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: transparent;
      color: inherit;
      min-width: 150px;
      cursor: pointer;
    }
    
    /* === Responsive Grids and Charts === */
    /* Asegurar que el gráfico y la tabla sean responsivos */
    @media (max-width: 768px) {
      #comparisonChartContainer, #chartContainer {
        height: 300px;
      }
      #cryptoChart, #comparisonChart {
        height: 100% !important;
      }
    }
    
    /* === Estilos para Recomendaciones en Comparación === */
    #comparisonRecommendation {
      text-align: center;
      margin-top: 20px;
      font-size: 1.1em;
      font-weight: bold;
    }
    .green-recommendation {
      color: #4CAF50;
    }
    .red-recommendation {
      color: #F44336;
    }
    .orange-recommendation {
      color: #FF9800;
    }
  </style>
</head>
<body class="dark">
  <h1>Monitor Criptomonedas</h1>
  <h3>by Pablo Bascoy</h3>

  <!-- Barra de progreso -->
  <div id="progressOverlay">
    <div id="progressMessage">Cargando criptomonedas...</div>
    <div id="progressBarContainer">
      <div id="progressBar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>

  <!-- Barra Superior con Botones "Favoritos" y "Ver Todos" -->
  <div class="top-bar">
    <div id="favoritesBar">
      <button id="btnFavoritos" class="btn btn-success">Favoritos</button>
      <button id="btnVerTodos" class="btn btn-secondary">Ver Todos</button>
    </div>
  </div>

  <!-- Explicación de RSI -->
  <div id="indicatorExplanation">
    <p><strong>¿Qué es el RSI (Relative Strength Index)?</strong></p>
    <p>El RSI mide la fortaleza o debilidad de un activo según sus últimos movimientos de precio, entre 0 y 100.</p>
    <ul>
      <li>RSI &gt; 70: Señal de venta.</li>
      <li>RSI &lt; 30: Señal de compra.</li>
      <li>RSI 30-70: Fase neutra.</li>
    </ul>
    <p>Las criptomonedas marcadas como favoritas aparecerán primero cada vez que se actualice (automático o manual).  
    Puedes actualizar manualmente o cada cierto número de segundos. El % de ganancia/pérdida se recalcula según tu precio de compra.</p>
  </div>

  <p id="lastUpdate">Última actualización: (sin datos)</p>

  <!-- Contenedor de Filtros -->
  <div id="filtersContainer">
    <div id="coinFilterContainer">
      <label for="coinFilter" title="Filtra por criptomoneda específica">Criptomoneda</label>
      <select id="coinFilter">
          <option value="all">Todas</option>
      </select>
    </div>
    <div id="rsiFilterContainer">
      <label for="rsiFilter" title="Filtra por estado del RSI">Estado RSI</label>
      <select id="rsiFilter">
          <option value="all">Todas</option>
          <option value="comprar">Comprar</option>
          <option value="vender">Vender</option>
          <option value="esperar">Esperar</option>
          <option value="neutral">Neutral</option>
      </select>
    </div>
  </div>

  <!-- Botón "Comparar Criptomonedas" Centrado Debajo de los Filtros -->
  <div style="text-align: center; margin-bottom: 20px;">
    <button id="compareCryptoBtn" class="btn btn-secondary">Comparar Criptomonedas</button>
  </div>

  <!-- Grilla de Criptomonedas -->
  <div id="cryptoGrid"></div>

  <!-- Modal Detallado -->
  <div id="modalOverlay">
    <div id="modalContent">
      <button class="btn btn-danger modalCloseBtn">Cerrar</button>
      <h2 id="modalTitle"></h2>
      <!-- Botón Actualizar que ahora solo actualiza la cripto del modal -->
      <button id="updateChartBtn" class="btn btn-info">Actualizar</button>
      <!-- Selector de Marco Temporal en el Modal -->
      <div id="modalTimeFrameContainer">
        <label for="modalTimeFrameFilter" title="Selecciona el marco temporal para el gráfico">Marco Temporal</label>
        <select id="modalTimeFrameFilter">
            <option value="5m">5 Minutos</option>
            <option value="15m">15 Minutos</option>
            <option value="1h">1 Hora</option>
            <option value="1d">Por Día</option>
            <option value="1w">Por Semana</option>
            <option value="1M">Por Mes</option>
            <option value="6M">Últimos 6 Meses</option>
            <option value="1Y">Último Año</option>
        </select>
      </div>
      <p id="lastUpdateModal"></p>
      <div class="modal-info" id="modalInfo"></div>
      <div id="chartContainer">
        <canvas id="cryptoChart"></canvas>
      </div>
      <!-- Botón para expandir el gráfico en móvil -->
      <button id="verAnalisisBtn" class="btn btn-warning">Ver Análisis</button>
      <!-- Botón para volver desde la vista expandida -->
      <button id="volverBtn" class="btn btn-danger">Regresar</button>

      <div id="priceAlertContainer">
        <label id="percentAlertLabel" title="Establece el porcentaje de ganancia para recibir una alerta">% de ganancia para alerta:
          <input type="number" id="priceAlertInput" placeholder="5">
        </label>
        <button id="setAlertBtn" class="btn btn-success">Set Alert</button>
      </div>

      <div id="buyPriceContainer">
        <label title="Ingresa tu precio de compra">Precio de Compra: $<input type="number" id="buyPriceInput" placeholder="0.00"></label>
        <button id="setBuyPriceBtn" class="btn btn-primary">Colocar precio de compra</button>
        <button id="clearBuyPriceBtn" class="btn btn-danger">Borrar precio de compra</button>
      </div>
      <div id="profitLossContainer">
        <p id="profitLossText">Ganancia/Perdida: 0%</p>
      </div>

      <div class="modal-explanation">
        <h4>Explicación de los Indicadores:</h4>
        <p><span style="color:#00ffcc;font-weight:bold;">RSI (Relative Strength Index):</span> Mide la velocidad y cambio de los movimientos de precios, oscila entre 0 y 100. Valores por encima de 70 indican sobrecompra, mientras que valores por debajo de 30 indican sobreventa.</p>
        <p><span style="color:#4CAF50;font-weight:bold;">SMA (Media Móvil Simple) de 7 periodos (verde):</span> Calcula el promedio de los precios de cierre de los últimos 7 periodos, proporcionando una visión de la tendencia a corto plazo.</p>
        <p><span style="color:#FF8C00;font-weight:bold;">SMA (Media Móvil Simple) de 30 periodos (naranja):</span> Calcula el promedio de los precios de cierre de los últimos 30 periodos, ofreciendo una perspectiva de la tendencia a largo plazo.</p>
        <p><span style="color:#00BFFF;font-weight:bold;">Volumen (azul):</span> Representa la cantidad de operaciones realizadas en cada periodo, indicando la fuerza detrás de los movimientos de precio.</p>
        <p><span style="color:#EE82EE;font-weight:bold;">Línea IA (violeta):</span> Predicción basada en inteligencia artificial que estima la tendencia futura del precio según patrones históricos.</p>
        <h4>Consejo:</h4>
        <p id="adviceText">(Se llenará con recomendaciones basadas en indicadores)</p>
      </div>

      <div class="modal-footer">
        <span id="dataSource"></span>
      </div>
    </div>
  </div>

  <!-- Modal de Comparación -->
  <div id="compareModalOverlay">
    <div id="compareModalContent">
      <button class="btn btn-danger modalCloseBtn">Cerrar</button>
      <h2>Comparación de Criptomonedas</h2>
      <div id="compareSelectorsContainer" style="display: flex; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap;">
        <select id="compareCrypto1" class="btn btn-default">
          <option value="">Selecciona Cripto 1</option>
        </select>
        <select id="compareCrypto2" class="btn btn-default">
          <option value="">Selecciona Cripto 2</option>
        </select>
        <button id="compareBtn" class="btn btn-primary" disabled>Comparar</button> <!-- Inicialmente deshabilitado -->
      </div>
      <div id="comparisonChartContainer">
        <canvas id="comparisonChart"></canvas>
      </div>
      <table id="comparisonTable">
        <thead>
          <tr>
            <th>Métrica</th>
            <th id="metric1">Cripto 1</th>
            <th id="metric2">Cripto 2</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Precio Actual</td>
            <td id="price1">-</td>
            <td id="price2">-</td>
          </tr>
          <tr>
            <td>Variación Precio (24h)
              <span class="tooltip">Cambio porcentual del precio en las últimas 24 horas.</span>
            </td>
            <td id="priceChange1">-</td>
            <td id="priceChange2">-</td>
          </tr>
          <tr>
            <td>Capitalización de Mercado
              <span class="tooltip">Valor total de todas las monedas en circulación.</span>
            </td>
            <td id="marketCap1">-</td>
            <td id="marketCap2">-</td>
          </tr>
          <tr>
            <td>Volumen (24h)
              <span class="tooltip">Cantidad total de operaciones realizadas en las últimas 24 horas.</span>
            </td>
            <td id="volume1">-</td>
            <td id="volume2">-</td>
          </tr>
          <tr>
            <td>On-Balance Volume (OBV)
              <span class="tooltip">Mide la presión de compra y venta acumulativa basada en el volumen.</span>
            </td>
            <td id="obv1">-</td>
            <td id="obv2">-</td>
          </tr>
          <tr>
            <td>Sentimiento del Mercado
              <span class="tooltip">Evaluación del sentimiento general del mercado hacia la criptomoneda.</span>
            </td>
            <td id="sentiment1">-</td>
            <td id="sentiment2">-</td>
          </tr>
          <tr>
            <td>Supply Circulante
              <span class="tooltip">Cantidad de monedas actualmente en circulación.</span>
            </td>
            <td id="circulatingSupply1">-</td>
            <td id="circulatingSupply2">-</td>
          </tr>
          <tr>
            <td>Supply Total
              <span class="tooltip">Cantidad total de monedas que existirán.</span>
            </td>
            <td id="totalSupply1">-</td>
            <td id="totalSupply2">-</td>
          </tr>
          <tr>
            <td>Dominancia de Mercado
              <span class="tooltip">Porcentaje de la capitalización de mercado de la criptomoneda respecto al total del mercado cripto.</span>
            </td>
            <td id="marketDominance1">-</td>
            <td id="marketDominance2">-</td>
          </tr>
          <tr>
            <td>Número de Transacciones Diarias
              <span class="tooltip">Cantidad de transacciones realizadas en las últimas 24 horas.</span>
            </td>
            <td id="transactions1">-</td>
            <td id="transactions2">-</td>
          </tr>
          <tr>
            <td>RSI (14)
              <span class="tooltip">Mide la fortaleza o debilidad del activo en los últimos 14 periodos.</span>
            </td>
            <td id="rsi1">-</td>
            <td id="rsi2">-</td>
          </tr>
          <!-- Más métricas según necesidad -->
        </tbody>
      </table>
      <!-- Botón para expandir el gráfico en móvil -->
      <button id="verAnalisisCompareBtn" class="btn btn-warning">Ver Análisis</button>
      <!-- Botón para volver desde la vista expandida -->
      <button id="volverCompareBtn" class="btn btn-danger">Regresar</button>
      <!-- Recomendación de Comparación -->
      <div id="comparisonRecommendation"></div>
    </div>
  </div>

  <!-- Botón de Tema -->
  <button id="themeToggle" class="btn btn-info">Tema</button>

  <!-- Botón Silenciar Alertas -->
  <button id="silenciarAlertasBtn" class="btn btn-warning">Silenciar Alertas</button>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Chart.js Zoom Plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

  <script>
    let chartInstance = null;
    let comparisonChartInstance = null; // Para el gráfico de comparación
    let cryptoData = [];
    let favorites = JSON.parse(localStorage.getItem('favorites')) || [];
    let priceAlerts = JSON.parse(localStorage.getItem('priceAlerts')) || {};
    let buyPrices = JSON.parse(localStorage.getItem('buyPrices')) || {};
    let currentModalCoinId = null;
    let currentModalCoinName = null;
    let currentModalPrice = null;
    let currentModalSymbol = null;
    let silenciarAlertas = false;
    let updateTimer = null;
    let favoritesActive = false; // Flag para controlar el filtro de favoritos
    let updateInterval = parseInt(localStorage.getItem('updateInterval')) || 30; // Intervalo por defecto

    // Referencias a elementos del DOM
    const body = document.body;
    const themeToggle = document.getElementById('themeToggle');
    const silenciarAlertasBtn = document.getElementById('silenciarAlertasBtn');
    const lastUpdateElement = document.getElementById('lastUpdate');
    const cryptoGrid = document.getElementById('cryptoGrid');
    const coinFilter = document.getElementById('coinFilter');
    const rsiFilter = document.getElementById('rsiFilter');
    const modalOverlay = document.getElementById('modalOverlay');
    const modalContent = document.getElementById('modalContent');
    const modalClose = modalContent.querySelector('.modalCloseBtn');
    const modalTitle = document.getElementById('modalTitle');
    const dataSource = document.getElementById('dataSource');
    const modalInfo = document.getElementById('modalInfo');
    const adviceText = document.getElementById('adviceText');
    const verAnalisisBtn = document.getElementById('verAnalisisBtn');
    const volverBtn = document.getElementById('volverBtn'); // Botón "Regresar"
    const lastUpdateModal = document.getElementById('lastUpdateModal');
    const priceAlertInput = document.getElementById('priceAlertInput');
    const setAlertBtn = document.getElementById('setAlertBtn');
    const buyPriceInput = document.getElementById('buyPriceInput');
    const setBuyPriceBtn = document.getElementById('setBuyPriceBtn');
    const clearBuyPriceBtn = document.getElementById('clearBuyPriceBtn');
    const profitLossText = document.getElementById('profitLossText');
    const btnFavoritos = document.getElementById('btnFavoritos');
    const btnVerTodos = document.getElementById('btnVerTodos');
    const updateChartBtn = document.getElementById('updateChartBtn');

    // Sección de Comparación
    const compareCryptoBtn = document.getElementById('compareCryptoBtn');
    const compareModalOverlay = document.getElementById('compareModalOverlay');
    const compareModalContent = document.getElementById('compareModalContent');
    const compareModalClose = compareModalContent.querySelector('.modalCloseBtn');
    const compareCrypto1Select = document.getElementById('compareCrypto1');
    const compareCrypto2Select = document.getElementById('compareCrypto2');
    const compareBtn = document.getElementById('compareBtn'); // Botón de comparación dentro del modal
    const comparisonChartCtx = document.getElementById('comparisonChart').getContext('2d');
    const comparisonTable = document.getElementById('comparisonTable');
    const metric1Header = document.getElementById('metric1');
    const metric2Header = document.getElementById('metric2');
    const price1Cell = document.getElementById('price1');
    const price2Cell = document.getElementById('price2');
    const priceChange1Cell = document.getElementById('priceChange1'); // Nueva referencia
    const priceChange2Cell = document.getElementById('priceChange2'); // Nueva referencia
    const marketCap1Cell = document.getElementById('marketCap1');
    const marketCap2Cell = document.getElementById('marketCap2');
    const volume1Cell = document.getElementById('volume1');
    const volume2Cell = document.getElementById('volume2');
    const obv1Cell = document.getElementById('obv1');
    const obv2Cell = document.getElementById('obv2');
    const sentiment1Cell = document.getElementById('sentiment1');
    const sentiment2Cell = document.getElementById('sentiment2');
    const circulatingSupply1Cell = document.getElementById('circulatingSupply1');
    const circulatingSupply2Cell = document.getElementById('circulatingSupply2');
    const totalSupply1Cell = document.getElementById('totalSupply1');
    const totalSupply2Cell = document.getElementById('totalSupply2');
    const marketDominance1Cell = document.getElementById('marketDominance1');
    const marketDominance2Cell = document.getElementById('marketDominance2');
    const transactions1Cell = document.getElementById('transactions1');
    const transactions2Cell = document.getElementById('transactions2');
    const rsi1CellCompare = document.getElementById('rsi1');
    const rsi2CellCompare = document.getElementById('rsi2');
    const verAnalisisCompareBtn = document.getElementById('verAnalisisCompareBtn');
    const volverCompareBtn = document.getElementById('volverCompareBtn');
    const comparisonRecommendation = document.getElementById('comparisonRecommendation');

    // Barra de progreso
    const progressOverlay = document.getElementById('progressOverlay');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const progressMessage = document.getElementById('progressMessage');

    // === 1) Manejo de tema (dark/light) ===
    const savedTheme = localStorage.getItem('theme') || 'dark';
    body.className = savedTheme;
    themeToggle.addEventListener('click', () => {
      body.className = (body.className === 'dark') ? 'light' : 'dark';
      localStorage.setItem('theme', body.className);
      // Actualizar colores de los gráficos si están activos
      if (chartInstance) {
        // Ajustar colores del gráfico
        chartInstance.options.scales.y.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y1.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.x.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y1.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.plugins.legend.labels.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.update();
      }
      if (comparisonChartInstance) {
        comparisonChartInstance.options.scales.y.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        comparisonChartInstance.options.scales.x.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        comparisonChartInstance.options.scales.y.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        comparisonChartInstance.options.plugins.legend.labels.color = body.className === 'dark' ? '#ffffff' : '#000000';
        comparisonChartInstance.update();
      }
    });

    // === 2) Botón silenciar alertas (voz) ===
    silenciarAlertasBtn.addEventListener('click', () => {
      silenciarAlertas = !silenciarAlertas;
      silenciarAlertasBtn.textContent = silenciarAlertas ? "Activar Alertas" : "Silenciar Alertas";
    });

    // === 3) Intervalo de actualización (global) ===
    // Eliminado: No se utilizan estos elementos

    // === 4) RSI y recomendación ===
    function calculateRSI(closePrices, period = 14) {
      if (closePrices.length < period) return null;
      let gains = 0;
      let losses = 0;
      for (let i = 1; i < period; i++) {
        const diff = closePrices[i] - closePrices[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      let avgGain = gains / (period - 1);
      let avgLoss = losses / (period - 1);

      let rsiArray = [null];
      for (let i = period; i < closePrices.length; i++) {
        const diff = closePrices[i] - closePrices[i - 1];
        const gain = diff > 0 ? diff : 0;
        const loss = diff < 0 ? -diff : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;

        if (avgLoss === 0) {
          rsiArray.push(100);
        } else {
          const rs = avgGain / avgLoss;
          rsiArray.push(100 - (100 / (1 + rs)));
        }
      }
      return rsiArray[rsiArray.length - 1];
    }

    function getRecommendationFromRSI(rsiValue) {
      if (rsiValue === null) {
        return { flag: 'neutral-flag', text: 'Neutral (Sin RSI)', state: 'neutral' };
      }
      if (rsiValue > 70) {
        return { flag: 'red-flag', text: 'Vender (RSI>70)', state: 'vender' };
      } else if (rsiValue < 30) {
        return { flag: 'green-flag', text: 'Comprar (RSI<30)', state: 'comprar' };
      } else {
        return { flag: 'neutral-flag', text: 'Esperar (RSI 30-70)', state: 'esperar' };
      }
    }

    // === 5) Voz (alertas) ===
    function speakMessage(text) {
      if (silenciarAlertas) return;
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'es-ES';
        utterance.rate = 1;
        utterance.pitch = 1;
        speechSynthesis.speak(utterance);
      }
    }

    // === 6) Creación de tarjetas (cards) para cada cripto en la pantalla principal ===
    function createCryptoCard(crypto, index, rsiRecommendation) {
      const binanceSymbol = (crypto.symbol.toUpperCase() + 'USDT');
      const isFav = favorites.includes(crypto.id);
      const star = isFav ? '★' : '☆';

      const card = document.createElement('div');
      card.className = 'crypto-card';
      card.setAttribute('data-coin-id', crypto.id);
      card.setAttribute('data-current-price', crypto.current_price);
      card.setAttribute('data-rsi-state', rsiRecommendation.state);

      card.innerHTML = `
        <div class="favorite-icon">${star}</div>
        <img src="${crypto.image}" alt="${crypto.name} logo" class="crypto-logo">
        <div class="crypto-name">${crypto.name}</div>
        <div class="crypto-price">$${crypto.current_price.toFixed(2)}</div>
        <div class="flag ${rsiRecommendation.flag}" title="RSI (Relative Strength Index): ${rsiRecommendation.text}">${rsiRecommendation.text}</div>
        <div class="mini-chart-container">
          <canvas id="miniChart-${index}" class="mini-chart"></canvas>
        </div>
      `;

      // Favorito
      card.querySelector('.favorite-icon').addEventListener('click', (e) => {
        e.stopPropagation();
        toggleFavorite(crypto.id, card);
      });

      // Abrir modal (clic o touch)
      card.addEventListener('click', () => {
        openModal(crypto.id, crypto.name, crypto.current_price, crypto.symbol.toUpperCase() + 'USDT');
      });

      return card;
    }

    function toggleFavorite(coinId, card) {
      if (favorites.includes(coinId)) {
        favorites = favorites.filter(f => f !== coinId);
        card.querySelector('.favorite-icon').textContent = '☆';
      } else {
        favorites.push(coinId);
        card.querySelector('.favorite-icon').textContent = '★';
      }
      localStorage.setItem('favorites', JSON.stringify(favorites));
      reorderCards();
      if (favoritesActive) {
        applyFilters();
      }
    }

    function reorderCards() {
      const cards = Array.from(document.querySelectorAll('.crypto-card'));
      const favCards = [];
      const otherCards = [];

      cards.forEach(card => {
        const coinId = card.getAttribute('data-coin-id');
        if (favorites.includes(coinId)) {
          favCards.push(card);
        } else {
          otherCards.push(card);
        }
      });

      cryptoGrid.innerHTML = '';
      favCards.forEach(c => cryptoGrid.appendChild(c));
      otherCards.forEach(c => cryptoGrid.appendChild(c));
    }

    // === 7) Carga de minigráfico (Binance) ===
    async function loadMiniChart(binanceSymbol, index) {
      try {
        // Utilizar un marco temporal fijo para mini gráficos, por ejemplo '5m'
        const miniTimeFrame = '5m';
        const endpoint = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=${miniTimeFrame}&limit=30`;
        const res = await fetch(endpoint, {cache:'no-store'});
        if (!res.ok) {
          console.warn(`No se pudo obtener datos de Binance para ${binanceSymbol}. Status: ${res.status}`);
          return false;
        }
        const klineData = await res.json();
        if (!Array.isArray(klineData) || klineData.length === 0) {
          console.warn(`No hay datos de kline para ${binanceSymbol}`);
          return false;
        }

        const closePrices = klineData.map(c => parseFloat(c[4]));
        const labels = klineData.map(c => {
          const date = new Date(c[0]);
          return `${date.getDate()}/${(date.getMonth()+1)} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
        });

        const miniCtx = document.getElementById(`miniChart-${index}`);
        if (!miniCtx) {
          console.warn(`Elemento canvas no encontrado para miniChart-${index}`);
          return false;
        }
        const miniChartCtx = miniCtx.getContext('2d');
        new Chart(miniChartCtx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              data: closePrices,
              borderColor: '#00ffcc',
              backgroundColor: 'rgba(0,255,204,0.1)',
              tension: 0.3,
              fill: true,
              pointRadius: 0
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { display: false },
              y: { display: false }
            },
            plugins: {
              legend: { display: false }
            }
          }
        });
        return true;
      } catch (e) {
        console.error('Error al cargar el mini gráfico:', e);
        return false;
      }
    }

    // === 8) PnL (Ganancia / Pérdida) en el modal ===
    function updateProfitLoss(coinId, currentPrice) {
      const buyVal = parseFloat(buyPrices[coinId] || 0);
      if (!isNaN(buyVal) && buyVal > 0) {
        const pnl = ((currentPrice - buyVal) / buyVal) * 100;
        let arrow = '';
        if (pnl > 0) {
          arrow = '<span class="green-recommendation">▲</span>';
        } else if (pnl < 0) {
          arrow = '<span class="red-recommendation">▼</span>';
        }
        profitLossText.innerHTML = `Ganancia/Perdida: ${pnl.toFixed(2)}% ${arrow}`;
      } else {
        profitLossText.textContent = `Ganancia/Perdida: 0%`;
      }
    }

    // === 9) Funciones para cargar TODAS las criptos o SOLO las favoritas ===
    async function fetchCryptoData(forceUpdate = false) {
      try {
        progressOverlay.style.display = 'flex';
        cryptoGrid.innerHTML = '';
        coinFilter.innerHTML = '<option value="all">Todas</option>';
        rsiFilter.value = 'all'; 
        btnFavoritos.disabled = true;
        btnVerTodos.disabled = true;
        coinFilter.disabled = true;
        rsiFilter.disabled = true;
        compareCryptoBtn.classList.remove('enabled');
        compareCryptoBtn.disabled = true;

        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=50&page=1&sparkline=false`;
        console.log(`Fetching data from CoinGecko: ${endpoint}`);
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error("No se obtuvieron datos de CoinGecko.");
        }
        cryptoData = data;

        const totalCryptos = data.length;
        let loadedCryptos = 0;

        // Llenar los select de comparación
        populateComparisonSelectors(data);

        // Procesar criptomonedas en batches para evitar sobrecarga de solicitudes
        const batchSize = 5; // Número de solicitudes simultáneas
        for (let i = 0; i < data.length; i += batchSize) {
          const batch = data.slice(i, i + batchSize);
          await Promise.all(batch.map(async (coin, idx) => {
            await createCardWithRSI(coin, i + idx, totalCryptos);
            loadedCryptos++;
            const progressPercentage = Math.round((loadedCryptos / totalCryptos) * 100);
            progressBar.style.width = `${progressPercentage}%`;
            progressText.textContent = `${progressPercentage}%`;
            progressMessage.textContent = `Cargando ${loadedCryptos} de ${totalCryptos} criptomonedas...`;
          }));
        }

        reorderCards();
        lastUpdateElement.textContent = `Última actualización: ${new Date().toLocaleString()}`;
        applyFilters();

        // Habilitar el botón de comparación
        compareCryptoBtn.classList.add('enabled');
        compareCryptoBtn.disabled = false;

        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      } catch (error) {
        console.error('Error al obtener datos:', error);
        alert(`Error al cargar criptomonedas: ${error.message}`);
        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      }
    }

    // Carga SOLO favoritas
    async function fetchFavoritesData() {
      try {
        progressOverlay.style.display = 'flex';
        cryptoGrid.innerHTML = '';
        coinFilter.innerHTML = '<option value="all">Todas</option>';
        rsiFilter.value = 'all'; 
        btnFavoritos.disabled = true;
        btnVerTodos.disabled = true;
        coinFilter.disabled = true;
        rsiFilter.disabled = true;
        compareCryptoBtn.classList.remove('enabled');
        compareCryptoBtn.disabled = true;

        if (favorites.length === 0) {
          // No hay favoritas, salimos
          progressOverlay.style.display = 'none';
          btnFavoritos.disabled = false;
          btnVerTodos.disabled = false;
          coinFilter.disabled = false;
          rsiFilter.disabled = false;
          return;
        }

        const favoritesIds = favorites.join('%2C'); 
        // Por ejemplo: "bitcoin%2Cethereum" en la query
        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${favoritesIds}&order=market_cap_desc&per_page=50&page=1&sparkline=false`;
        console.log(`Fetching favorite data from CoinGecko: ${endpoint}`);
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error("No se obtuvieron datos de las favoritas.");
        }
        cryptoData = data;

        const totalCryptos = data.length;
        let loadedCryptos = 0;

        // Llenar los select de comparación solo con favoritas
        populateComparisonSelectors(data, true);

        // Procesar criptomonedas en batches para evitar sobrecarga de solicitudes
        const batchSize = 5; // Número de solicitudes simultáneas
        for (let i = 0; i < data.length; i += batchSize) {
          const batch = data.slice(i, i + batchSize);
          await Promise.all(batch.map(async (coin, idx) => {
            await createCardWithRSI(coin, i + idx, totalCryptos);
            loadedCryptos++;
            const progressPercentage = Math.round((loadedCryptos / totalCryptos) * 100);
            progressBar.style.width = `${progressPercentage}%`;
            progressText.textContent = `${progressPercentage}%`;
            progressMessage.textContent = `Cargando favoritas (${loadedCryptos}/${totalCryptos})...`;
          }));
        }

        reorderCards();
        lastUpdateElement.textContent = `Última actualización: ${new Date().toLocaleString()}`;
        applyFilters();

        // Habilitar el botón de comparación
        compareCryptoBtn.classList.add('enabled');
        compareCryptoBtn.disabled = false;

        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      } catch (error) {
        console.error('Error al cargar favoritas:', error);
        alert(`Error al cargar favoritas: ${error.message}`);
        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      }
    }

    // === 10) Crear card con RSI (para uso en fetchCryptoData y fetchFavoritesData) ===
    async function createCardWithRSI(coin, index, totalCryptos) {
      const binanceSymbol = (coin.symbol.toUpperCase() + 'USDT');
      let rsiValue = null;
      try {
        const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=5m&limit=30`, { cache: 'no-store' }); // Usando '5m' para mini gráficos
        if (res.ok) {
          const klineData = await res.json();
          const closePrices = klineData.map(c => parseFloat(c[4]));
          if (closePrices.length > 0) {
            rsiValue = calculateRSI(closePrices, 14);
          }
        } else {
          console.warn(`No se pudo obtener datos de Binance para ${binanceSymbol}. Status: ${res.status}`);
        }
      } catch (err) {
        console.error(`Error al obtener RSI para ${coin.name}:`, err);
        // error silencioso
      }
      const rsiRec = getRecommendationFromRSI(rsiValue);

      if (!silenciarAlertas && favorites.includes(coin.id) && rsiValue !== null) {
        const percentAlert = parseFloat(priceAlerts['globalPercentAlert'] || 5);
        if (rsiValue >= 70) {
          const buyVal = parseFloat(buyPrices[coin.id] || 0);
          if (buyVal > 0) {
            const pnl = ((coin.current_price - buyVal) / buyVal) * 100;
            if (pnl >= percentAlert) {
              speakMessage(`Se sugiere vender ${coin.name}. Ganancia de ${pnl.toFixed(2)} porciento, RSI: ${rsiValue.toFixed(2)}`);
            }
          }
        } else if (rsiValue < 30) {
          const buyVal = parseFloat(buyPrices[coin.id] || 0);
          if (buyVal === 0) {
            speakMessage(`Se sugiere comprar ${coin.name}. RSI: ${rsiValue.toFixed(2)}. Sin precio de compra configurado.`);
          }
        }
      }

      const card = createCryptoCard(coin, index, rsiRec);
      cryptoGrid.appendChild(card);

      // Añadir opciones al filtro de criptomonedas
      // Verificar si la opción ya existe para evitar duplicados
      if (!Array.from(coinFilter.options).some(option => option.value === coin.id)) {
        const opt = document.createElement('option');
        opt.value = coin.id;
        opt.textContent = coin.name;
        coinFilter.appendChild(opt);
      }

      // Añadir opciones a los selects de comparación
      if (!compareCrypto1Select.querySelector(`option[value="${coin.id}"]`)) {
        const opt1 = document.createElement('option');
        opt1.value = coin.id;
        opt1.textContent = coin.name;
        compareCrypto1Select.appendChild(opt1);
      }
      if (!compareCrypto2Select.querySelector(`option[value="${coin.id}"]`)) {
        const opt2 = document.createElement('option');
        opt2.value = coin.id;
        opt2.textContent = coin.name;
        compareCrypto2Select.appendChild(opt2);
      }

      const loaded = await loadMiniChart(binanceSymbol, index);
      if (!loaded) {
        card.querySelector('.mini-chart-container').innerHTML = `<p class="no-chart-text">Sin datos de gráfico</p>`;
      }
    }

    // === 11) Carga y Actualización de UNA sola cripto (para el modal) ===
    // Esto se usará cuando en el modal se presione "Actualizar", para NO recargar las 50.
    async function fetchSingleCoinData(coinId) {
      try {
        // Llamada a la API para 1 sola criptomoneda
        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coinId}&order=market_cap_desc&per_page=1&page=1&sparkline=false`;
        console.log(`Fetching single coin data from CoinGecko: ${endpoint}`);
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error(`No se obtuvieron datos para ${coinId}.`);
        }
        const coin = data[0];
        currentModalCoinId = coin.id;
        currentModalCoinName = coin.name;
        currentModalPrice = coin.current_price;
        currentModalSymbol = coin.symbol.toUpperCase() + 'USDT';

        // Volvemos a cargar el modal con loadModalData
        await loadModalData(currentModalCoinId, currentModalCoinName, currentModalPrice, currentModalSymbol);
      } catch (error) {
        console.error('Error al obtener datos de una sola criptomoneda:', error);
        alert(`Error al actualizar ${coinId}: ${error.message}`);
      }
    }

    // === 12) Apertura del modal ===
    async function openModal(coinId, coinName, currentPrice, binanceSymbol) {
      currentModalCoinId = coinId;
      currentModalCoinName = coinName;
      currentModalPrice = currentPrice;
      currentModalSymbol = binanceSymbol;
      // Inicializar el marco temporal del modal a '5m'
      modalTimeFrameFilter.value = '5m';
      await loadModalData(coinId, coinName, currentPrice, binanceSymbol);
    }

    // === 13) Carga del modal (gráfico principal) ===
    async function loadModalData(coinId, coinName, currentPrice, binanceSymbol) {
      try {
        const modalTimeFrame = modalTimeFrameFilter.value; // Obtener el marco temporal seleccionado en el modal
        // Verificar si el intervalo es soportado por Binance
        const supportedIntervals = ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '8h', '12h', '1d', '3d', '1w', '1M'];
        if (!supportedIntervals.includes(modalTimeFrame)) {
          throw new Error(`Intervalo de tiempo "${modalTimeFrame}" no soportado por Binance.`);
        }

        const endpoint = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=${modalTimeFrame}&limit=100`;
        console.log(`Fetching modal data from Binance: ${endpoint}`);
        const response = await fetch(endpoint, {cache:'no-store'});
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const klineData = await response.json();
        if (!Array.isArray(klineData) || klineData.length === 0) {
          throw new Error(`Sin datos para ${coinName}.`);
        }

        const closePrices = klineData.map(c => parseFloat(c[4]));
        const volumes = klineData.map(c => parseFloat(c[5]));
        const labels = klineData.map(c => {
          const date = new Date(c[0]);
          const year = String(date.getFullYear()).slice(-2); // two-digit year
          return `${date.getDate()}/${(date.getMonth()+1)}/${year} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
        });

        // RSI
        const rsiValue = calculateRSI(closePrices, 14);
        const rsiRec = getRecommendationFromRSI(rsiValue);

        modalTitle.textContent = `${coinName} - Tendencia: ${rsiRec.text}`;
        dataSource.textContent = endpoint;

        modalInfo.innerHTML = `
          <p>Precio Actual: $${currentPrice.toFixed(2)}</p>
          <p>RSI (14): ${rsiValue ? rsiValue.toFixed(2) : 'N/A'}</p>
        `;

        modalOverlay.style.display = 'flex';

        // Destruimos un chart anterior
        if (chartInstance) {
          chartInstance.destroy();
        }

        // IA line
        const aiPredictions = generateAIPrediction(closePrices);
        const aiLabels = [];
        for (let i = 1; i <= aiPredictions.length; i++) {
          aiLabels.push(`Futuro+${i}`);
        }

        // SMA
        const shortSMA = calculateSMA(closePrices, 7);
        const longSMA = calculateSMA(closePrices, 30);

        // Preparar los datos para el gráfico
        const aiLine = Array(closePrices.length).fill(null).concat(aiPredictions);

        setTimeout(() => {
          chartInstance = new Chart(document.getElementById('cryptoChart').getContext('2d'), {
            data: {
              labels: labels.concat(aiLabels),
              datasets: [
                {
                  type: 'line',
                  label: `${coinName} (USD)`,
                  data: closePrices.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#00ffcc',
                  backgroundColor: 'rgba(0,255,204,0.1)',
                  tension: 0.3,
                  fill: true,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: `SMA (7)`,
                  data: shortSMA.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#FFD700',
                  fill: false,
                  pointRadius: 0,
                  tension: 0.2,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: `SMA (30)`,
                  data: longSMA.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#FF8C00',
                  fill: false,
                  pointRadius: 0,
                  tension: 0.2,
                  yAxisID: 'y',
                },
                {
                  type: 'bar',
                  label: 'Volumen',
                  data: volumes.concat(Array(aiPredictions.length).fill(null)),
                  backgroundColor: 'rgba(0,191,255,0.3)',
                  borderColor: '#00BFFF',
                  borderWidth: 1,
                  yAxisID: 'y1'
                },
                {
                  type: 'line',
                  label: 'Línea IA (Predicción)',
                  data: aiLine,
                  borderColor: '#EE82EE',
                  borderDash: [2, 2],
                  pointRadius: 0,
                  fill: false,
                  tension: 0.2,
                  yAxisID: 'y',
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              scales: {
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Precio (USD)',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Volumen',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  },
                  grid: {
                    drawOnChartArea: false,
                  },
                },
                x: {
                  ticks: { 
                    color: body.className === 'dark' ? '#ffffff' : '#000000',
                    callback: function(value, index, values) {
                      return this.getLabelForValue(value);
                    }
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                },
                zoom: { // Configuración del plugin de zoom
                  pan: {
                    enabled: true,
                    mode: 'xy',
                  },
                  zoom: {
                    wheel: {
                      enabled: true,
                    },
                    pinch: {
                      enabled: true
                    },
                    mode: 'xy',
                  }
                }
              },
            }
          });
          chartInstance.update();
        }, 100);

        fillAdviceAndComments();
        lastUpdateModal.textContent = `Última actualización: ${new Date().toLocaleString()}`;

        if (buyPrices[coinId]) {
          buyPriceInput.value = buyPrices[coinId];
        } else {
          buyPriceInput.value = "";
        }
        updateProfitLoss(coinId, currentPrice);
      } catch (error) {
        console.error('Error al mostrar modal con gráfico:', error);
        alert(`Error al cargar datos del gráfico: ${error.message}`);
        modalTitle.textContent = `${coinName} - Sin datos de gráfico`;
        modalInfo.innerHTML = `<p>No se pudieron obtener datos del gráfico. Intente más tarde.</p>`;
        adviceText.textContent = "No hay suficientes datos para dar un consejo.";
        dataSource.textContent = "";
        modalOverlay.style.display = 'flex';
        lastUpdateModal.textContent = "";
      }
    }

    function fillAdviceAndComments() {
      const randomAdvice = [
        "Observa también el volumen para mayor precisión.",
        "Ten en cuenta la tendencia global del mercado.",
        "Considera noticias recientes que puedan afectar al activo.",
        "Combina RSI con otras medias móviles para más eficacia.",
        "Analiza la volatilidad antes de comprar o vender."
      ];
      adviceText.textContent = randomAdvice[Math.floor(Math.random() * randomAdvice.length)];
    }

    // === 14) Cierre del modal ===
    modalClose.addEventListener('click', () => {
      cerrarModal();
    });

    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) {
        cerrarModal();
      }
    });

    function cerrarModal() {
      modalOverlay.classList.remove('expanded-view'); // Remover clase de vista expandida si existe
      cerrarVistaExpandida();
      modalOverlay.style.display = 'none';
    }

    // === 15) Botón "Ver Análisis" (Expandir gráfico) ===
    verAnalisisBtn.addEventListener('click', () => {
      const isMobile = window.matchMedia("only screen and (max-width: 768px)").matches;
      if (isMobile) {
        // Expandir el modal a pantalla completa
        modalOverlay.classList.add('expanded-view');

        if (chartInstance) {
          // Reajustar el tamaño del gráfico
          chartInstance.resize();
          chartInstance.update();
        }

        // Mostrar botón "Regresar" y ocultar "Ver Análisis"
        verAnalisisBtn.style.display = 'none';
        volverBtn.style.display = 'block';
      } else {
        // Para escritorio, podrías implementar otra funcionalidad si lo deseas
        alert("Esta funcionalidad está optimizada para dispositivos móviles.");
      }
    });

    // === 16) Botón "Volver" (Revertir expansión del gráfico) ===
    volverBtn.addEventListener('click', () => {
      cerrarVistaExpandida();
    });

    function cerrarVistaExpandida() {
      modalOverlay.classList.remove('expanded-view');
      if (chartInstance) {
        chartInstance.resize();
        chartInstance.update();
      }

      // Mostrar botón "Ver Análisis" y ocultar "Regresar"
      verAnalisisBtn.style.display = 'block';
      volverBtn.style.display = 'none';
    }

    // === Nueva: Listener para cambios de orientación ===
    window.addEventListener('orientationchange', () => {
      if (modalOverlay.classList.contains('expanded-view') && chartInstance) {
        chartInstance.resize();
        chartInstance.update();
      }
      if (compareModalOverlay.classList.contains('expanded-view') && comparisonChartInstance) {
        comparisonChartInstance.resize();
        comparisonChartInstance.update();
      }
    });

    // === 17) Botones de Alertas ===
    setAlertBtn.addEventListener('click', () => {
      const percentVal = parseFloat(priceAlertInput.value);
      if (!isNaN(percentVal) && percentVal > 0) {
        priceAlerts['globalPercentAlert'] = percentVal;
        localStorage.setItem('priceAlerts', JSON.stringify(priceAlerts));
        speakMessage(`Has establecido la alerta de ganancia en ${percentVal} porciento.`);
      } else {
        alert("Por favor, ingresa un valor válido para la alerta.");
      }
    });

    setBuyPriceBtn.addEventListener('click', () => {
      if (currentModalCoinId && buyPriceInput.value) {
        const buyPrice = parseFloat(buyPriceInput.value);
        if (!isNaN(buyPrice) && buyPrice > 0) {
          buyPrices[currentModalCoinId] = buyPrice;
          localStorage.setItem('buyPrices', JSON.stringify(buyPrices));
          updateProfitLoss(currentModalCoinId, currentModalPrice);
          speakMessage(`Precio de compra establecido para ${currentModalCoinId} en ${buyPrice} dólares.`);
        } else {
          alert("Por favor, ingresa un precio de compra válido.");
        }
      } else {
        alert("No hay una criptomoneda seleccionada o el precio de compra está vacío.");
      }
    });

    clearBuyPriceBtn.addEventListener('click', () => {
      if (currentModalCoinId) {
        delete buyPrices[currentModalCoinId];
        localStorage.setItem('buyPrices', JSON.stringify(buyPrices));
        buyPriceInput.value = "";
        profitLossText.textContent = "Ganancia/Perdida: 0%";
        speakMessage(`Precio de compra eliminado para ${currentModalCoinId}.`);
      }
    });

    // === 18) Botones de Favoritos y Ver Todos ===
    btnFavoritos.addEventListener('click', async () => {
      favoritesActive = true;
      await fetchFavoritesData();
    });

    btnVerTodos.addEventListener('click', async () => {
      favoritesActive = false;
      await fetchCryptoData(true);
    });

    // === 19) Botón "Actualizar" en el Modal ===
    updateChartBtn.addEventListener('click', async () => {
      // Llamamos a fetchSingleCoinData para actualizar solo esta cripto
      if (currentModalCoinId) {
        await fetchSingleCoinData(currentModalCoinId);
      }
    });

    // === 20) Selector de Marco Temporal en el Modal ===
    modalTimeFrameFilter.addEventListener('change', async () => {
      // Si el modal está abierto, actualizar su gráfico
      if (modalOverlay.style.display === 'flex' && currentModalCoinId) {
        await loadModalData(currentModalCoinId, currentModalCoinName, currentModalPrice, currentModalSymbol);
      }
    });

    // === 21) Función de Filtros ===
    function applyFilters() {
      const selectedCoin = coinFilter.value;
      const selectedRSI = rsiFilter.value;

      const cards = document.querySelectorAll('.crypto-card');
      cards.forEach(card => {
        let display = true;

        // Filtro de Favoritos
        if (favoritesActive) {
          const coinId = card.getAttribute('data-coin-id');
          if (!favorites.includes(coinId)) {
            display = false;
          }
        }

        // Filtro de Criptomoneda
        if (selectedCoin !== 'all') {
          const coinId = card.getAttribute('data-coin-id');
          if (coinId !== selectedCoin) {
            display = false;
          }
        }

        // Filtro de RSI
        if (selectedRSI !== 'all') {
          const rsiState = card.getAttribute('data-rsi-state');
          if (selectedRSI !== rsiState) {
            display = false;
          }
        }

        card.style.display = display ? 'block' : 'none';
      });

      // Reordenar después de aplicar filtros
      reorderCards();
    }

    function resetFilters() {
      coinFilter.value = 'all';
      rsiFilter.value = 'all';
      cryptoGrid.querySelectorAll('.crypto-card').forEach(card => {
        card.style.display = 'block';
      });
      reorderCards();
    }

    // === 22) Función para manejar la expansión del gráfico en móviles con un solo clic ===
    // Ya está implementada mediante los botones "Ver Análisis" y "Regresar"

    // === 23) Función de Inicio ===
    async function initialize() {
      // Añadir Event Listeners para los filtros
      coinFilter.addEventListener('change', applyFilters);
      rsiFilter.addEventListener('change', applyFilters);

      // Añadir Event Listener para el botón de Comparación
      compareCryptoBtn.addEventListener('click', () => {
        openCompareModal();
      });

      // Añadir Event Listener para el cierre del modal de comparación
      compareModalClose.addEventListener('click', () => {
        cerrarCompareModal();
      });

      // Añadir Event Listener para el modal de comparación al hacer clic fuera del contenido
      compareModalOverlay.addEventListener('click', (e) => {
        if (e.target === compareModalOverlay) {
          cerrarCompareModal();
        }
      });

      // Añadir Event Listener para el botón de "Regresar" en el modal de comparación
      volverCompareBtn.addEventListener('click', () => {
        cerrarVistaExpandidaCompare();
      });

      // Event Listeners para habilitar el botón "Comparar" dentro del modal
      compareCrypto1Select.addEventListener('change', checkCompareButtonState);
      compareCrypto2Select.addEventListener('change', checkCompareButtonState);

      // Primer fetch según estado inicial (Ver Todos o Favoritos)
      if (favoritesActive) {
        await fetchFavoritesData();
      } else {
        await fetchCryptoData(false);
      }

      // Iniciar el timer de actualización
      startUpdateTimer();
    }

    // === 24) Timer de Actualización ===
    function startUpdateTimer() {
      if (updateTimer) {
        clearInterval(updateTimer);
      }
      updateTimer = setInterval(async () => {
        if (favoritesActive) {
          await fetchFavoritesData();
        } else {
          await fetchCryptoData(true);
        }
      }, updateInterval * 1000);
    }

    // === 25) Funciones Extra ===
    function calculateSMA(data, length) {
      const sma = [];
      for (let i = 0; i < data.length; i++) {
        if (i < length - 1) {
          sma.push(null);
        } else {
          const slice = data.slice(i - length + 1, i + 1);
          const sum = slice.reduce((a, b) => a + b, 0);
          sma.push(sum / length);
        }
      }
      return sma;
    }

    function generateAIPrediction(closePrices) {
      const predictions = [];
      const lastPrice = closePrices[closePrices.length - 1];
      for (let i = 1; i <= 10; i++) {
        const factor = 1 + (Math.random() - 0.5) * 0.02;
        predictions.push(lastPrice * factor);
      }
      return predictions;
    }

    // === 26) Función para Llenar los Selects de Comparación ===
    function populateComparisonSelectors(data, isFavorites = false) {
      const select1 = compareCrypto1Select;
      const select2 = compareCrypto2Select;
      // Limpiar opciones excepto la primera
      select1.innerHTML = '<option value="">Selecciona Cripto 1</option>';
      select2.innerHTML = '<option value="">Selecciona Cripto 2</option>';

      data.forEach(coin => {
        const option1 = document.createElement('option');
        option1.value = coin.id;
        option1.textContent = coin.name;
        select1.appendChild(option1);

        const option2 = document.createElement('option');
        option2.value = coin.id;
        option2.textContent = coin.name;
        select2.appendChild(option2);
      });
    }

    // === 27) Función para Comparar Criptomonedas ===
    compareBtn.addEventListener('click', async () => {
      const crypto1 = compareCrypto1Select.value;
      const crypto2 = compareCrypto2Select.value;

      if (!crypto1 || !crypto2) {
        alert('Por favor, selecciona ambas criptomonedas para comparar.');
        return;
      }

      if (crypto1 === crypto2) {
        alert('Selecciona dos criptomonedas diferentes para comparar.');
        return;
      }

      try {
        // Mostrar barra de progreso
        progressOverlay.style.display = 'flex';
        progressMessage.textContent = 'Cargando datos para la comparación...';
        progressBar.style.width = '0%';
        progressText.textContent = '0%';

        // Fetch data desde CoinGecko
        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${crypto1},${crypto2}&order=market_cap_desc&per_page=2&page=1&sparkline=false`;
        console.log(`Fetching comparison data from CoinGecko: ${endpoint}`);
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length < 2) {
          throw new Error("No se obtuvieron suficientes datos de CoinGecko para la comparación.");
        }

        const [data1, data2] = data;

        // Actualizar la tabla
        metric1Header.textContent = data1.name;
        metric2Header.textContent = data2.name;
        price1Cell.textContent = `$${data1.current_price.toLocaleString()}`;
        price2Cell.textContent = `$${data2.current_price.toLocaleString()}`;
        // Variación del Precio (24h)
        priceChange1Cell.textContent = data1.price_change_percentage_24h !== null ? `${data1.price_change_percentage_24h.toFixed(2)}%` : 'N/A';
        priceChange2Cell.textContent = data2.price_change_percentage_24h !== null ? `${data2.price_change_percentage_24h.toFixed(2)}%` : 'N/A';
        // Capitalización de Mercado
        marketCap1Cell.textContent = data1.market_cap ? `$${data1.market_cap.toLocaleString()}` : 'N/A';
        marketCap2Cell.textContent = data2.market_cap ? `$${data2.market_cap.toLocaleString()}` : 'N/A';
        // Volumen (24h)
        volume1Cell.textContent = data1.total_volume ? `$${data1.total_volume.toLocaleString()}` : 'N/A';
        volume2Cell.textContent = data2.total_volume ? `$${data2.total_volume.toLocaleString()}` : 'N/A';
        // RSI (14) - Simulación, ya que CoinGecko no proporciona RSI
        // Para la comparación, utilizaremos un RSI simulado basado en la variación de precios
        const rsiValue1 = simulateRSI(data1.price_change_percentage_24h);
        const rsiValue2 = simulateRSI(data2.price_change_percentage_24h);
        rsi1CellCompare.textContent = rsiValue1 !== null ? rsiValue1.toFixed(2) : 'N/A';
        rsi2CellCompare.textContent = rsiValue2 !== null ? rsiValue2.toFixed(2) : 'N/A';

        // On-Balance Volume (OBV) - Simulación
        obv1Cell.textContent = calculateOBV(data1) || 'N/A';
        obv2Cell.textContent = calculateOBV(data2) || 'N/A';

        // Sentimiento del Mercado - Simulación
        sentiment1Cell.textContent = getMarketSentiment();
        sentiment2Cell.textContent = getMarketSentiment();

        // Supply Circulante y Total
        circulatingSupply1Cell.textContent = data1.circulating_supply ? `${data1.circulating_supply.toLocaleString()} ${data1.symbol.toUpperCase()}` : 'N/A';
        circulatingSupply2Cell.textContent = data2.circulating_supply ? `${data2.circulating_supply.toLocaleString()} ${data2.symbol.toUpperCase()}` : 'N/A';
        totalSupply1Cell.textContent = data1.total_supply ? `${data1.total_supply.toLocaleString()} ${data1.symbol.toUpperCase()}` : 'N/A';
        totalSupply2Cell.textContent = data2.total_supply ? `${data2.total_supply.toLocaleString()} ${data2.symbol.toUpperCase()}` : 'N/A';

        // Dominancia de Mercado
        marketDominance1Cell.textContent = data1.market_cap_rank ? `${data1.market_cap_rank}` : 'N/A';
        marketDominance2Cell.textContent = data2.market_cap_rank ? `${data2.market_cap_rank}` : 'N/A';

        // Número de Transacciones Diarias - Simulación
        transactions1Cell.textContent = getDailyTransactions();
        transactions2Cell.textContent = getDailyTransactions();

        // Fetch historiales de precios para el gráfico
        const days = 30; // Puedes hacer que el usuario elija el período
        const history1 = await fetch(`https://api.coingecko.com/api/v3/coins/${crypto1}/market_chart?vs_currency=usd&days=${days}`);
        const history2 = await fetch(`https://api.coingecko.com/api/v3/coins/${crypto2}/market_chart?vs_currency=usd&days=${days}`);
        const historyData1 = await history1.json();
        const historyData2 = await history2.json();

        const labels1 = historyData1.prices.map(price => {
          const date = new Date(price[0]);
          return `${date.getMonth()+1}/${date.getDate()}`;
        });
        const labels2 = historyData2.prices.map(price => {
          const date = new Date(price[0]);
          return `${date.getMonth()+1}/${date.getDate()}`;
        });

        // Asegurar que ambas series tengan el mismo número de etiquetas
        const minLength = Math.min(labels1.length, labels2.length);
        const labels = labels1.slice(-minLength);
        const prices1 = historyData1.prices.slice(-minLength).map(price => price[1]);
        const prices2 = historyData2.prices.slice(-minLength).map(price => price[1]);

        // Calcular RSI para ambas criptomonedas (simulado)
        const rsiValue1Final = calculateRSI(prices1, 14);
        const rsiValue2Final = calculateRSI(prices2, 14);
        rsi1CellCompare.textContent = rsiValue1Final !== null ? rsiValue1Final.toFixed(2) : 'N/A';
        rsi2CellCompare.textContent = rsiValue2Final !== null ? rsiValue2Final.toFixed(2) : 'N/A';

        // Crear o actualizar el gráfico de comparación
        if (comparisonChartInstance) {
          comparisonChartInstance.data.labels = labels;
          comparisonChartInstance.data.datasets[0].data = prices1;
          comparisonChartInstance.data.datasets[1].data = prices2;
          comparisonChartInstance.update();
        } else {
          comparisonChartInstance = new Chart(comparisonChartCtx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: data1.name,
                  data: prices1,
                  borderColor: 'rgba(75, 192, 192, 1)',
                  backgroundColor: 'rgba(75, 192, 192, 0.2)',
                  fill: true,
                  tension: 0.3,
                },
                {
                  label: data2.name,
                  data: prices2,
                  borderColor: 'rgba(255, 99, 132, 1)',
                  backgroundColor: 'rgba(255, 99, 132, 0.2)',
                  fill: true,
                  tension: 0.3,
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              scales: {
                x: { display: true },
                y: { 
                  display: true,
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Precio (USD)',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                },
                zoom: { // Configuración del plugin de zoom
                  pan: {
                    enabled: true,
                    mode: 'xy',
                  },
                  zoom: {
                    wheel: {
                      enabled: true,
                    },
                    pinch: {
                      enabled: true
                    },
                    mode: 'xy',
                  }
                }
              },
            }
          });
        }

        // Determinar recomendaciones basadas en RSI
        const recommendation1 = determineAction(rsiValue1Final);
        const recommendation2 = determineAction(rsiValue2Final);

        // Mostrar recomendaciones debajo del gráfico
        comparisonRecommendation.innerHTML = `
          <p>${data1.name}: <span class="${getRecommendationClass(recommendation1)}">${recommendation1}</span></p>
          <p>${data2.name}: <span class="${getRecommendationClass(recommendation2)}">${recommendation2}</span></p>
        `;

        // Actualizar el progreso
        progressBar.style.width = '100%';
        progressText.textContent = '100%';
        progressMessage.textContent = 'Comparación completada.';
        setTimeout(() => {
          progressOverlay.style.display = 'none';
        }, 500);
      } catch (error) {
        console.error('Error al comparar criptomonedas:', error);
        alert(`Error: ${error.message}`);
        progressOverlay.style.display = 'none';
      }
    });

    // === 28) Función para Cerrar el Modal de Comparación ===
    function cerrarCompareModal() {
      compareModalOverlay.classList.remove('expanded-view');
      cerrarVistaExpandidaCompare();
      compareModalOverlay.style.display = 'none';
      // Limpiar recomendaciones
      comparisonRecommendation.innerHTML = '';
    }

    // === 29) Función para Abrir el Modal de Comparación ===
    function openCompareModal() {
      compareModalOverlay.style.display = 'flex';
    }

    // === 30) Botón "Ver Análisis" en el Modal de Comparación ===
    verAnalisisCompareBtn.addEventListener('click', () => {
      const isMobile = window.matchMedia("only screen and (max-width: 768px)").matches;
      if (isMobile) {
        // Expandir el modal a pantalla completa
        compareModalOverlay.classList.add('expanded-view');

        if (comparisonChartInstance) {
          // Reajustar el tamaño del gráfico
          comparisonChartInstance.resize();
          comparisonChartInstance.update();
        }

        // Mostrar botón "Regresar" y ocultar "Ver Análisis"
        verAnalisisCompareBtn.style.display = 'none';
        volverCompareBtn.style.display = 'block';
      } else {
        // Para escritorio, podrías implementar otra funcionalidad si lo deseas
        alert("Esta funcionalidad está optimizada para dispositivos móviles.");
      }
    });

    // === 31) Botón "Volver" en el Modal de Comparación ===
    volverCompareBtn.addEventListener('click', () => {
      cerrarVistaExpandidaCompare();
    });

    function cerrarVistaExpandidaCompare() {
      compareModalOverlay.classList.remove('expanded-view');
      if (comparisonChartInstance) {
        comparisonChartInstance.resize();
        comparisonChartInstance.update();
      }

      // Mostrar botón "Ver Análisis" y ocultar "Regresar"
      verAnalisisCompareBtn.style.display = 'block';
      volverCompareBtn.style.display = 'none';
    }

    // === 32) Función de Filtros ===
    // Ya implementada en applyFilters()

    // === 33) Carga Inicial ===
    initialize();

    // === 34) Función para Comparar RSI y Decidir Acción ===
    function determineAction(rsiValue) {
      if (rsiValue === null) {
        return 'Esperar';
      }
      if (rsiValue > 70) {
        return 'Vender';
      } else if (rsiValue < 30) {
        return 'Comprar';
      } else {
        return 'Esperar';
      }
    }

    function getRecommendationClass(action) {
      if (action === 'Comprar') return 'green-recommendation';
      if (action === 'Vender') return 'red-recommendation';
      return 'orange-recommendation';
    }

    // === Funciones adicionales para nuevos indicadores ===

    // Función simulada para calcular On-Balance Volume (OBV)
    function calculateOBV(coinData) {
      // CoinGecko no proporciona OBV directamente. Normalmente, se calcula a partir de los precios y volúmenes históricos.
      // Aquí simulamos un valor.
      return Math.floor(Math.random() * 1000000).toLocaleString();
    }

    // Función simulada para obtener Sentimiento del Mercado
    function getMarketSentiment() {
      const sentiments = ['Positivo', 'Neutral', 'Negativo'];
      return sentiments[Math.floor(Math.random() * sentiments.length)];
    }

    // Función simulada para obtener Número de Transacciones Diarias
    function getDailyTransactions() {
      // CoinGecko no proporciona este dato directamente. Simulamos un valor.
      return Math.floor(Math.random() * 10000).toLocaleString();
    }

    // === Función para Simular RSI Basado en Variación de Precio ===
    function simulateRSI(priceChangePercentage) {
      if (priceChangePercentage === null || isNaN(priceChangePercentage)) return null;
      // Simplemente mapea el cambio de precio a un RSI simulado
      if (priceChangePercentage > 5) return 80; // Alto RSI
      if (priceChangePercentage < -5) return 20; // Bajo RSI
      return 50; // RSI neutral
    }

    // === Implementar lógica para habilitar el botón "Comparar" cuando se seleccionan dos criptomonedas ===
    function checkCompareButtonState() {
      if (compareCrypto1Select.value && compareCrypto2Select.value && compareCrypto1Select.value !== compareCrypto2Select.value) {
        compareBtn.classList.add('enabled');
        compareBtn.disabled = false;
      } else {
        compareBtn.classList.remove('enabled');
        compareBtn.disabled = true;
      }
    }

  </script>
</body>
</html>
