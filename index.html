<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Monitor Criptomonedas - RSI + PnL + Voz + Favoritas Primero</title>
  <style>
    /* Estilos generales */
    body.dark {
      background-color: #0a0e17;
      color: #ffffff;
    }
    body.light {
      background-color: #f0f0f0;
      color: #000000;
    }
    body {
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 20px;
      transition: background-color 0.3s, color 0.3s;
    }
    h1 {
      text-align: center;
      color: #00ffcc;
      font-size: 2.5em;
      margin-bottom: 5px;
    }
    h3 {
      text-align: center;
      color: #7a8599;
      margin-top: -10px;
      font-size: 0.9em;
      font-weight: normal;
    }
    #indicatorExplanation {
      max-width: 800px;
      margin: 10px auto 20px auto;
      background-color: #1a2332;
      border-radius: 10px;
      padding: 15px;
      color: #ccc;
      font-size: 0.9em;
    }
    body.light #indicatorExplanation {
      background-color: #eaeaea;
      color: #333;
    }
    #indicatorExplanation p {
      margin: 5px 0;
      line-height: 1.3em;
    }
    #lastUpdate {
      text-align: center;
      margin-top: 5px;
      font-style: italic;
      color: #7a8599;
      margin-bottom: 20px;
    }
    #filtersContainer {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    #coinFilterContainer,
    #rsiFilterContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #1a2332;
      border-radius: 15px;
      padding: 10px;
    }
    body.light #coinFilterContainer,
    body.light #rsiFilterContainer {
      background-color: #eaeaea;
    }
    label {
      margin-bottom: 5px;
      font-weight: bold;
    }
    select {
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: transparent;
      color: inherit;
    }
    #coinFilter {
      background-color: #0a0e17;
      color: #ffffff;
      border: 1px solid #00ffcc;
      border-radius: 10px;
      padding: 10px;
      min-width: 150px;
    }

    #rsiFilter {
      background-color: #0a0e17;
      color: #ffffff;
      border: 1px solid #00ffcc;
      border-radius: 10px;
      padding: 10px;
      min-width: 150px;
    }

    #intervalContainer {
      text-align: center;
      margin-top: 10px;
      margin-bottom: 20px;
    }
    #intervalContainer label {
      margin-right: 5px;
    }
    #updateIntervalInput {
      width: 60px;
      padding: 5px;
      border-radius: 5px;
      border: none;
    }
    #setIntervalBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #00ffcc;
      color: #0a0e17;
      cursor: pointer;
    }

    #cryptoGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }
    .crypto-card {
      background-color: #1a2332;
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
      cursor: pointer;
      position: relative;
    }
    body.light .crypto-card {
      background-color: #ffffff;
      color: #000000;
    }
    .crypto-card:hover {
      transform: translateY(-5px);
    }
    .crypto-card:hover::after {
      content: "Doble clic para ver gráfico";
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #00ffcc;
      color: #0a0e17;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      white-space: nowrap;
    }
    .crypto-logo {
      width: 60px;
      height: 60px;
      margin-bottom: 15px;
    }
    .crypto-name {
      font-size: 1.2em;
      font-weight: bold;
      margin-bottom: 10px;
      word-break: break-word;
    }
    .crypto-price {
      font-size: 1.1em;
      margin-bottom: 15px;
    }
    .flag {
      display: inline-block;
      padding: 8px 15px;
      border-radius: 20px;
      font-weight: bold;
      text-transform: uppercase;
      font-size: 0.9em;
      white-space: nowrap;
    }
    .green-flag {
      background-color: #4CAF50;
      color: white;
    }
    .red-flag {
      background-color: #F44336;
      color: white;
    }
    .neutral-flag {
      background-color: #FF9800;
      color: white;
    }
    .mini-chart-container {
      margin-top: 15px;
      position: relative;
      height: 80px;
    }
    canvas.mini-chart {
      width: 100%;
      height: 100%;
    }
    .no-chart-text {
      margin-top: 15px;
      font-size: 0.8em;
      color: #7a8599;
    }
    .favorite-icon {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: 1.2em;
      color: #ffc107;
    }
    #error {
      text-align: center;
      color: #F44336;
      font-size: 1.2em;
      margin-top: 50px;
      display: none;
    }
    #modalOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      padding: 0;
    }
    #modalContent {
      background: #1a2332;
      border-radius: 15px;
      width: 95vw;
      height: 95vh;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding: 20px;
    }
    body.light #modalContent {
      background: #f0f0f0;
      color: #000000;
    }
    #modalClose {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #00ffcc;
      color: #0a0e17;
      border: none;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
      padding: 10px;
      border-radius: 5px;
    }
    #chartContainer {
      width: 100%;
      min-height: 300px;
      margin-bottom: 20px;
      position: relative;
    }
    #cryptoChart {
      width: 100%;
      height: 100%;
    }
    .modal-footer {
      font-size: 0.9em;
      color: #7a8599;
      text-align: center;
      word-break: break-all;
      margin-top: 20px;
    }
    body.light .modal-footer {
      color: #333333;
    }
    .modal-info {
      text-align: center;
      margin-bottom: 10px;
    }
    .modal-info p {
      margin: 5px 0;
    }
    .modal-explanation {
      font-size: 0.9em;
      margin-top: 15px;
      background-color: #0a0e17;
      padding: 10px;
      border-radius: 10px;
    }
    body.light .modal-explanation {
      background-color: #ddd;
      color: #000;
    }
    .modal-explanation h4 {
      margin-top: 10px;
      margin-bottom: 5px;
    }
    #priceAlertContainer {
      margin: 10px 0;
      text-align: center;
    }
    #percentAlertLabel {
      display: inline-block;
      margin-right: 5px;
    }
    #priceAlertInput {
      width: 60px;
      padding: 5px;
      border-radius: 5px;
      border: none;
    }
    #setAlertBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #00ffcc;
      color: #0a0e17;
      cursor: pointer;
    }
    #buyPriceContainer {
      margin: 10px 0;
      text-align: center;
    }
    #buyPriceInput {
      width: 100px;
      padding: 5px;
      border-radius: 5px;
      border: none;
    }
    #setBuyPriceBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #00ffcc;
      color: #0a0e17;
      cursor: pointer;
    }
    #clearBuyPriceBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #F44336;
      color: white;
      cursor: pointer;
    }
    #profitLossContainer {
      margin: 10px 0;
      text-align: center;
    }
    #profitLossText {
      margin: 5px;
      font-weight: bold;
    }
    .green-arrow {
      color: #00ff00;
      font-weight: bold;
    }
    .red-arrow {
      color: #ff4444;
      font-weight: bold;
    }
    #themeToggle {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background-color: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 0.8em;
      z-index: 2000;
    }
    #favoritesBar {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 5px;
      z-index: 1000;
    }
    #btnFavoritos, #btnVerTodos {
      background-color: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 8px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 0.8em;
    }
    #updateChartBtn {
      background: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px auto 5px auto;
      display: block;
      font-size: 0.9em;
    }
    #lastUpdateModal {
      text-align: center;
      font-style: italic;
      color: #7a8599;
      margin-top: 5px;
      margin-bottom: 10px;
    }
    #verAnalisisBtn {
      background: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px auto 0 auto;
      display: block;
      font-size: 0.9em;
    }
    #silenciarAlertasBtn {
      background: #FF9800;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      cursor: pointer;
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 2100;
    }
    /* Estilos para la barra de progreso */
    #progressOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 4000;
      flex-direction: column;
      color: #ffffff;
      font-size: 1.2em;
      flex-wrap: wrap;
    }
    #progressBarContainer {
      width: 80%;
      background-color: #ddd;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 20px;
    }
    #progressBar {
      width: 0%;
      height: 30px;
      background-color: #00ffcc;
      transition: width 0.3s;
    }
    @media (max-width: 768px) {
      #modalContent {
        width: 98vw;
        height: 98vh;
      }
      #progressBarContainer {
        width: 90%;
      }
    }
  </style>
</head>
<body class="dark">
  <h1>Monitor Criptomonedas</h1>
  <h3>by Pablo Bascoy</h3>

  <!-- Barra de progreso -->
  <div id="progressOverlay">
    <div id="progressMessage">Cargando criptomonedas...</div>
    <div id="progressBarContainer">
      <div id="progressBar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>

  <!-- Explicación de RSI -->
  <div id="indicatorExplanation">
    <p><strong>¿Qué es el RSI (Relative Strength Index)?</strong></p>
    <p>El RSI mide la fortaleza o debilidad de un activo según sus últimos movimientos de precio, entre 0 y 100.</p>
    <ul>
      <li>RSI &gt; 70: Señal de venta.</li>
      <li>RSI &lt; 30: Señal de compra.</li>
      <li>RSI 30-70: Fase neutra.</li>
    </ul>
    <p>Las criptomonedas marcadas como favoritas aparecerán primero cada vez que se actualice (automático o manual).  
    Puedes actualizar manualmente o cada cierto número de segundos. El % de ganancia/pérdida se recalcula según tu precio de compra.</p>
  </div>

  <p id="lastUpdate">Última actualización: (sin datos)</p>

  <div id="intervalContainer">
    <label>Actualización (segundos):
      <input type="number" id="updateIntervalInput" placeholder="30">
    </label>
    <button id="setIntervalBtn">Set Interval</button>
  </div>

  <div id="filtersContainer">
    <div id="coinFilterContainer">
      <label for="coinFilter">Criptomoneda</label>
      <select id="coinFilter">
          <option value="all">Todas</option>
      </select>
    </div>
    <div id="rsiFilterContainer">
      <label for="rsiFilter">Estado RSI</label>
      <select id="rsiFilter">
          <option value="all">Todas</option>
          <option value="comprar">Comprar</option>
          <option value="vender">Vender</option>
          <option value="esperar">Esperar</option>
          <option value="neutral">Neutral</option>
      </select>
    </div>
  </div>

  <div id="error">No se pudo acceder a los datos en tiempo real. Por favor, intente más tarde.</div>
  <div id="cryptoGrid"></div>

  <div id="modalOverlay">
    <div id="modalContent">
      <button id="modalClose">Regresar</button>
      <h2 id="modalTitle"></h2>
      <button id="updateChartBtn">Actualizar</button>
      <p id="lastUpdateModal"></p>
      <div class="modal-info" id="modalInfo"></div>
      <div id="chartContainer">
        <canvas id="cryptoChart"></canvas>
      </div>
      <button id="verAnalisisBtn">Ver Análisis</button>

      <div id="priceAlertContainer">
        <label id="percentAlertLabel">% de ganancia para alerta:
          <input type="number" id="priceAlertInput" placeholder="5">
        </label>
        <button id="setAlertBtn">Set Alert</button>
      </div>

      <div id="buyPriceContainer">
        <label>Precio de Compra: $<input type="number" id="buyPriceInput" placeholder="0.00"></label>
        <button id="setBuyPriceBtn">Colocar precio de compra</button>
        <button id="clearBuyPriceBtn">Borrar precio de compra</button>
      </div>
      <div id="profitLossContainer">
        <p id="profitLossText">Ganancia/Perdida: 0%</p>
      </div>

      <div class="modal-explanation">
        <h4>Explicación de los Indicadores:</h4>
        <p><span style="color:#00ffcc;font-weight:bold;">Línea principal (cyan):</span> Representa el <strong>precio histórico</strong> de la criptomoneda durante el período analizado.</p>
        <p><span style="color:#4CAF50;font-weight:bold;">Línea de tendencia (verde/punteada):</span> Indica la <strong>tendencia actual</strong> del precio, ayudando a identificar si el precio está en alza, baja o en una fase lateral.</p>
        <p><span style="color:#FFD700;font-weight:bold;">SMA (7) (amarillo):</span> Es la <strong>Media Móvil Simple de 7 periodos</strong>, que suaviza las fluctuaciones de precio a corto plazo para identificar tendencias recientes.</p>
        <p><span style="color:#FF8C00;font-weight:bold;">SMA (30) (naranja):</span> Es la <strong>Media Móvil Simple de 30 periodos</strong>, que proporciona una visión de las tendencias a mediano plazo.</p>
        <p><span style="color:#00BFFF;font-weight:bold;">Volumen (azul):</span> Muestra la <strong>cantidad de operaciones</strong> realizadas durante cada periodo, lo que puede indicar la fuerza detrás de los movimientos de precio.</p>
        <p><span style="color:#EE82EE;font-weight:bold;">Línea IA (violeta):</span> Representa la <strong>predicción de inteligencia artificial</strong>, proyectando posibles movimientos futuros del precio basados en patrones históricos.</p>
        <h4>Consejo:</h4>
        <p id="adviceText">(Se llenará con consejos aleatorios)</p>
      </div>

      <div class="modal-footer">
        <span id="dataSource"></span>
      </div>
    </div>
  </div>

  <button id="themeToggle">Tema</button>
  <div id="favoritesBar">
    <button id="btnFavoritos">Favoritos</button>
    <button id="btnVerTodos">Ver Todos</button>
  </div>

  <button id="silenciarAlertasBtn">Silenciar Alertas</button>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <script>
    let chartInstance = null;
    let cryptoData = [];
    let favorites = JSON.parse(localStorage.getItem('favorites')) || [];
    let priceAlerts = JSON.parse(localStorage.getItem('priceAlerts')) || {};
    let buyPrices = JSON.parse(localStorage.getItem('buyPrices')) || {};
    let currentModalCoinId = null;
    let currentModalCoinName = null;
    let currentModalPrice = null;
    let currentModalSymbol = null;
    let silenciarAlertas = false;
    let updateTimer = null;
    let favoritesActive = false; // Flag para controlar el filtro de favoritos

    // Intervalo por defecto 30 seg
    let updateInterval = parseInt(localStorage.getItem('updateInterval')) || 30;

    const body = document.body;
    const themeToggle = document.getElementById('themeToggle');
    const silenciarAlertasBtn = document.getElementById('silenciarAlertasBtn');
    const lastUpdateElement = document.getElementById('lastUpdate');
    const errorElement = document.getElementById('error');
    const cryptoGrid = document.getElementById('cryptoGrid');
    const coinFilter = document.getElementById('coinFilter');
    const rsiFilter = document.getElementById('rsiFilter');
    const modalOverlay = document.getElementById('modalOverlay');
    const modalClose = document.getElementById('modalClose');
    const modalTitle = document.getElementById('modalTitle');
    const dataSource = document.getElementById('dataSource');
    const modalInfo = document.getElementById('modalInfo');
    const adviceText = document.getElementById('adviceText');
    const verAnalisisBtn = document.getElementById('verAnalisisBtn');
    const lastUpdateModal = document.getElementById('lastUpdateModal');
    const priceAlertInput = document.getElementById('priceAlertInput');
    const setAlertBtn = document.getElementById('setAlertBtn');
    const buyPriceInput = document.getElementById('buyPriceInput');
    const setBuyPriceBtn = document.getElementById('setBuyPriceBtn');
    const clearBuyPriceBtn = document.getElementById('clearBuyPriceBtn');
    const profitLossText = document.getElementById('profitLossText');
    const btnFavoritos = document.getElementById('btnFavoritos');
    const btnVerTodos = document.getElementById('btnVerTodos');
    const updateChartBtn = document.getElementById('updateChartBtn');
    const updateIntervalInputElem = document.getElementById('updateIntervalInput');
    const setIntervalBtnElem = document.getElementById('setIntervalBtn');

    // Barra de progreso
    const progressOverlay = document.getElementById('progressOverlay');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const progressMessage = document.getElementById('progressMessage');

    // Tema
    const savedTheme = localStorage.getItem('theme') || 'dark';
    body.className = savedTheme;

    themeToggle.addEventListener('click', () => {
      body.className = (body.className === 'dark') ? 'light' : 'dark';
      localStorage.setItem('theme', body.className);
      // Actualizar colores de los gráficos si están abiertos
      if (chartInstance) {
        chartInstance.options.scales.y.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y1.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.x.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y1.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.plugins.legend.labels.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.update();
      }
    });

    // Botón silenciar
    silenciarAlertasBtn.addEventListener('click', () => {
      silenciarAlertas = !silenciarAlertas;
      silenciarAlertasBtn.textContent = silenciarAlertas ? "Activar Alertas" : "Silenciar Alertas";
    });

    // Intervalo configurable
    updateIntervalInputElem.value = updateInterval;
    setIntervalBtnElem.addEventListener('click', () => {
      const newVal = parseInt(updateIntervalInputElem.value);
      if (!isNaN(newVal) && newVal > 0) {
        updateInterval = newVal;
        localStorage.setItem('updateInterval', updateInterval);
        speakMessage(`Intervalo de actualización configurado a ${updateInterval} segundos.`);
        if (updateTimer) clearInterval(updateTimer);
        startUpdateTimer();
      }
    });

    // RSI
    function calculateRSI(closePrices, period = 14) {
      if (closePrices.length < period) return null;
      let gains = 0;
      let losses = 0;
      for (let i = 1; i < period; i++) {
        const diff = closePrices[i] - closePrices[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      let avgGain = gains / (period - 1);
      let avgLoss = losses / (period - 1);

      let rsiArray = [null];
      for (let i = period; i < closePrices.length; i++) {
        const diff = closePrices[i] - closePrices[i - 1];
        const gain = diff > 0 ? diff : 0;
        const loss = diff < 0 ? -diff : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;

        if (avgLoss === 0) {
          rsiArray.push(100);
        } else {
          const rs = avgGain / avgLoss;
          rsiArray.push(100 - (100 / (1 + rs)));
        }
      }
      return rsiArray[rsiArray.length - 1];
    }

    function getRecommendationFromRSI(rsiValue) {
      if (rsiValue === null) {
        return { flag: 'neutral-flag', text: 'Neutral (Sin RSI)', state: 'neutral' };
      }
      if (rsiValue > 70) {
        return { flag: 'red-flag', text: 'Vender (RSI>70)', state: 'vender' };
      } else if (rsiValue < 30) {
        return { flag: 'green-flag', text: 'Comprar (RSI<30)', state: 'comprar' };
      } else if (rsiValue >= 30 && rsiValue <= 70) {
        return { flag: 'neutral-flag', text: 'Esperar (RSI 30-70)', state: 'esperar' };
      } else {
        return { flag: 'neutral-flag', text: 'Neutral (Sin RSI)', state: 'neutral' };
      }
    }

    // Voz
    function speakMessage(text) {
      if (silenciarAlertas) return;
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'es-ES';
        utterance.rate = 1;
        utterance.pitch = 1;
        speechSynthesis.speak(utterance);
      }
    }

    // Creación y actualización de cards
    function createCryptoCard(crypto, index, rsiRecommendation) {
      const card = document.createElement('div');
      card.className = 'crypto-card';
      card.setAttribute('data-coin-id', crypto.id);
      card.setAttribute('data-coin-name', crypto.name);
      card.setAttribute('data-current-price', crypto.current_price);
      card.setAttribute('data-rsi-state', rsiRecommendation.state); // Asegurarse que es en minúsculas

      const isFav = favorites.includes(crypto.id);
      const star = isFav ? '★' : '☆';

      card.innerHTML = `
        <div class="favorite-icon">${star}</div>
        <img src="${crypto.image}" alt="${crypto.name} logo" class="crypto-logo">
        <div class="crypto-name">${crypto.name}</div>
        <div class="crypto-price">$${crypto.current_price.toFixed(2)}</div>
        <div class="flag ${rsiRecommendation.flag}">${rsiRecommendation.text}</div>
        <div class="mini-chart-container">
          <canvas id="miniChart-${index}" class="mini-chart"></canvas>
        </div>
      `;

      // Favorito
      const favIcon = card.querySelector('.favorite-icon');
      favIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleFavorite(crypto.id, card);
      });

      // Doble click / double tap
      let lastTap = 0;
      card.addEventListener('dblclick', () => {
        openModal(crypto.id, crypto.name, crypto.current_price, crypto.symbol.toUpperCase() + 'USDT');
      });
      card.addEventListener('touchend', (event) => {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        if (tapLength < 300 && tapLength > 0) {
          openModal(crypto.id, crypto.name, crypto.current_price, crypto.symbol.toUpperCase() + 'USDT');
          event.preventDefault();
        }
        lastTap = currentTime;
      });

      return card;
    }

    function toggleFavorite(coinId, card) {
      if (favorites.includes(coinId)) {
        favorites = favorites.filter(f => f !== coinId);
        card.querySelector('.favorite-icon').textContent = '☆';
      } else {
        favorites.push(coinId);
        card.querySelector('.favorite-icon').textContent = '★';
      }
      localStorage.setItem('favorites', JSON.stringify(favorites));
      reorderCards();
      if (favoritesActive) {
        applyFilters(); // Reaplicar filtros si está activo
      }
    }

    /**
     * Reordena para que las favoritas vayan siempre primero.
     */
    function reorderCards() {
      const cards = Array.from(document.querySelectorAll('.crypto-card'));
      const favCards = [];
      const otherCards = [];

      cards.forEach(card => {
        const coinId = card.getAttribute('data-coin-id');
        if (favorites.includes(coinId)) {
          favCards.push(card);
        } else {
          otherCards.push(card);
        }
      });

      cryptoGrid.innerHTML = '';
      // Primero favoritas
      favCards.forEach(c => cryptoGrid.appendChild(c));
      // Luego las demás
      otherCards.forEach(c => cryptoGrid.appendChild(c));
    }

    async function loadMiniChart(binanceSymbol, index) {
      try {
        const endpoint = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=1m&limit=30`;
        const res = await fetch(endpoint, {cache:'no-store'});
        if (!res.ok) return false;
        const klineData = await res.json();
        if (!Array.isArray(klineData) || klineData.length === 0) return false;

        const closePrices = klineData.map(c => parseFloat(c[4]));
        const labels = klineData.map(c => {
          const date = new Date(c[0]);
          return `${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
        });

        const miniCtx = document.getElementById(`miniChart-${index}`);
        if (!miniCtx) return false;
        const miniChartCtx = miniCtx.getContext('2d');
        new Chart(miniChartCtx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              data: closePrices,
              borderColor: '#00ffcc',
              backgroundColor: 'rgba(0,255,204,0.1)',
              tension: 0.3,
              fill: true,
              pointRadius: 0
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { display: false },
              y: { display: false }
            },
            plugins: {
              legend: { display: false }
            }
          }
        });
        return true;
      } catch (e) {
        return false;
      }
    }

    // PnL
    function updateProfitLoss(coinId, currentPrice) {
      const buy = parseFloat(buyPrices[coinId] || 0);
      if (!isNaN(buy) && buy > 0) {
        const pnl = ((currentPrice - buy) / buy) * 100;
        let arrow = '';
        if (pnl > 0) {
          arrow = '<span class="green-arrow">▲</span>';
        } else if (pnl < 0) {
          arrow = '<span class="red-arrow">▼</span>';
        }
        profitLossText.innerHTML = `Ganancia/Perdida: ${pnl.toFixed(2)}% ${arrow}`;
      } else {
        profitLossText.textContent = `Ganancia/Perdida: 0%`;
      }
    }

    async function fetchCryptoData(forceUpdate = false) {
      try {
        // Mostrar barra de progreso y desactivar interacciones
        progressOverlay.style.display = 'flex';
        cryptoGrid.innerHTML = '';
        coinFilter.innerHTML = '<option value="all">Todas</option>';
        rsiFilter.value = 'all'; // Reset RSI filter
        btnFavoritos.disabled = true;
        btnVerTodos.disabled = true;
        coinFilter.disabled = true;
        rsiFilter.disabled = true;

        const response = await fetch(
          'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=50&page=1&sparkline=false',
          { cache: 'no-store' }
        );
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error("No se obtuvieron datos de CoinGecko.");
        }
        cryptoData = data;

        const totalCryptos = data.length;
        let loadedCryptos = 0;

        // Limpiar cryptoGrid y reiniciar filtros
        cryptoGrid.innerHTML = '';
        coinFilter.innerHTML = '<option value="all">Todas</option>';

        for (let coin of data) {
          await createCardWithRSI(coin, loadedCryptos, totalCryptos);
          loadedCryptos++;
          const progressPercentage = Math.round((loadedCryptos / totalCryptos) * 100);
          progressBar.style.width = `${progressPercentage}%`;
          progressText.textContent = `${progressPercentage}%`;
          progressMessage.textContent = `Cargando ${loadedCryptos} de ${totalCryptos} criptomonedas...`;
        }

        // Reordenamos (favoritas primero)
        reorderCards();

        lastUpdateElement.textContent = `Última actualización: ${new Date().toLocaleString()}`;

        // Recalcular PnL
        for (const coin of data) {
          if (buyPrices[coin.id]) {
            const card = document.querySelector(`.crypto-card[data-coin-id="${coin.id}"]`);
            if (card) {
              card.setAttribute('data-current-price', coin.current_price);
              if (coin.id === currentModalCoinId) {
                updateProfitLoss(coin.id, coin.current_price);
              }
            }
          }
        }

        applyFilters(); // Aplicar filtros después de cargar los datos

        // Ocultar barra de progreso y habilitar interacciones
        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;

      } catch (error) {
        console.error('Error al obtener datos:', error);
        errorElement.style.display = 'block';
        errorElement.textContent = 'No se pudo acceder a los datos en tiempo real. Por favor, intente más tarde.';
        // Ocultar barra de progreso y habilitar interacciones
        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      }
    }

    async function createCardWithRSI(crypto, loadedCryptos, totalCryptos) {
      const binanceSymbol = (crypto.symbol.toUpperCase() + 'USDT');
      let rsiValue = null;
      try {
        const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=1m&limit=30`, { cache: 'no-store' });
        if (res.ok) {
          const klineData = await res.json();
          const closePrices = klineData.map(c => parseFloat(c[4]));
          if (closePrices.length > 0) {
            rsiValue = calculateRSI(closePrices, 14);
          }
        }
      } catch (err) {
        // Manejo silencioso de errores de fetch de Binance
      }
      const rsiRec = getRecommendationFromRSI(rsiValue);

      // Alertas de voz
      if (!silenciarAlertas && favorites.includes(crypto.id) && rsiValue !== null) {
        const percentAlert = parseFloat(priceAlerts['globalPercentAlert'] || 5);

        // RSI vender
        if (rsiValue >= 70) {
          const buyVal = parseFloat(buyPrices[crypto.id] || 0);
          if (buyVal > 0) {
            const pnl = ((crypto.current_price - buyVal) / buyVal) * 100;
            if (pnl >= percentAlert) {
              speakMessage(`Se sugiere vender ${crypto.name}. Ganancia de ${pnl.toFixed(2)} porciento, RSI: ${rsiValue.toFixed(2)}`);
            }
          }
        }
        // RSI comprar
        else if (rsiValue < 30) {
          const buyVal = parseFloat(buyPrices[crypto.id] || 0);
          if (buyVal === 0) {
            speakMessage(`Se sugiere comprar ${crypto.name}. RSI: ${rsiValue.toFixed(2)}. Sin precio de compra configurado.`);
          }
        }
      }

      // Crear card
      const card = createCryptoCard(crypto, loadedCryptos, rsiRec);
      cryptoGrid.appendChild(card);

      // Añadir option al select
      const opt = document.createElement('option');
      opt.value = crypto.id; // Usar ID para facilitar el filtrado
      opt.textContent = crypto.name;
      coinFilter.appendChild(opt);

      const loaded = await loadMiniChart(binanceSymbol, loadedCryptos);
      if (!loaded) {
        card.querySelector('.mini-chart-container').innerHTML = `<p class="no-chart-text">Sin datos de gráfico</p>`;
      }
    }

    async function openModal(coinId, coinName, currentPrice, binanceSymbol) {
      currentModalCoinId = coinId;
      currentModalCoinName = coinName;
      currentModalPrice = currentPrice;
      currentModalSymbol = binanceSymbol;
      await loadModalData(coinId, coinName, currentPrice, binanceSymbol);
    }

    async function loadModalData(coinId, coinName, currentPrice, binanceSymbol) {
      try {
        const endpoint = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=1m&limit=100`;
        const response = await fetch(endpoint, {cache:'no-store'});
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const klineData = await response.json();
        if (!Array.isArray(klineData) || klineData.length === 0) {
          throw new Error(`Sin datos para ${coinName}.`);
        }

        const closePrices = klineData.map(c => parseFloat(c[4]));
        const volumes = klineData.map(c => parseFloat(c[5]));
        const labels = klineData.map(c => {
          const date = new Date(c[0]);
          return `${date.getDate()}/${(date.getMonth()+1)} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
        });

        const lastPrice = closePrices[closePrices.length - 1];
        const trendValues = closePrices.map(() => lastPrice);

        const shortSMA = calculateSMA(closePrices, 7);
        const longSMA = calculateSMA(closePrices, 30);

        // CoinGecko
        const coingeckoDetails = await fetch(`https://api.coingecko.com/api/v3/coins/${coinId}`, {cache:'no-store'});
        const detailsData = await coingeckoDetails.json();
        const marketCap = detailsData.market_data?.market_cap?.usd || 'N/A';
        const volume24h = detailsData.market_data?.total_volume?.usd || 'N/A';

        const aiPredictions = generateAIPrediction(closePrices);
        const aiLabels = [];
        for (let i = 1; i <= aiPredictions.length; i++) {
          aiLabels.push(`Futuro+${i}`);
        }

        const rsiValue = calculateRSI(closePrices, 14);
        const rsiRec = getRecommendationFromRSI(rsiValue);
        const modalRecColor = (rsiRec.flag === 'green-flag') ? '#4CAF50'
                                : (rsiRec.flag === 'red-flag') ? '#F44336'
                                : '#FF9800';

        modalTitle.textContent = `${coinName} - Tendencia: ${rsiRec.text}`;
        dataSource.textContent = endpoint;

        modalInfo.innerHTML = `
          <p>Precio Actual: $${currentPrice.toFixed(2)}</p>
          <p>Market Cap: $${parseFloat(marketCap).toLocaleString()}</p>
          <p>Volumen 24h: $${parseFloat(volume24h).toLocaleString()}</p>
          <p>RSI (14): ${rsiValue ? rsiValue.toFixed(2) : 'N/A'}</p>
        `;

        modalOverlay.style.display = 'flex';

        if (chartInstance) {
          chartInstance.destroy();
        }

        // IA line
        const aiLine = Array(closePrices.length).fill(null).concat(aiPredictions);

        setTimeout(() => {
          chartInstance = new Chart(document.getElementById('cryptoChart').getContext('2d'), {
            data: {
              labels: labels.concat(aiLabels),
              datasets: [
                {
                  type: 'line',
                  label: `${coinName} (USD)`,
                  data: closePrices.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#00ffcc',
                  backgroundColor: 'rgba(0,255,204,0.1)',
                  tension: 0.3,
                  fill: true,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: `Línea de tendencia (${rsiRec.text})`,
                  data: trendValues.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: modalRecColor,
                  borderDash: [5, 5],
                  pointRadius: 0,
                  fill: false,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: 'SMA (7)',
                  data: shortSMA.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#FFD700',
                  fill: false,
                  pointRadius: 0,
                  tension: 0.2,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: 'SMA (30)',
                  data: longSMA.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#FF8C00',
                  fill: false,
                  pointRadius: 0,
                  tension: 0.2,
                  yAxisID: 'y',
                },
                {
                  type: 'bar',
                  label: 'Volumen',
                  data: volumes.concat(Array(aiPredictions.length).fill(null)),
                  backgroundColor: 'rgba(0,191,255,0.3)',
                  borderColor: '#00BFFF',
                  borderWidth: 1,
                  yAxisID: 'y1'
                },
                {
                  type: 'line',
                  label: 'Línea IA (Predicción)',
                  data: aiLine,
                  borderColor: '#EE82EE',
                  borderDash: [2, 2],
                  pointRadius: 0,
                  fill: false,
                  tension: 0.2,
                  yAxisID: 'y',
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              scales: {
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Precio (USD)',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Volumen',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  },
                  grid: {
                    drawOnChartArea: false,
                  },
                },
                x: {
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                }
              }
            }
          });
          chartInstance.update();
        }, 100);

        fillAdviceAndComments(detailsData);
        lastUpdateModal.textContent = `Última actualización: ${new Date().toLocaleString()}`;

        if (buyPrices[coinId]) {
          buyPriceInput.value = buyPrices[coinId];
        } else {
          buyPriceInput.value = "";
        }
        updateProfitLoss(coinId, currentPrice);

      } catch (error) {
        console.error('Error al mostrar modal con gráfico:', error);
        modalTitle.textContent = `${coinName} - Sin datos de gráfico`;
        modalInfo.innerHTML = `<p>No se pudieron obtener datos del gráfico. Intente más tarde.</p>`;
        adviceText.textContent = "No hay suficientes datos para dar un consejo.";
        dataSource.textContent = "";
        modalOverlay.style.display = 'flex';
        lastUpdateModal.textContent = "";
      }
    }

    function fillAdviceAndComments(detailsData) {
      const randomAdvice = [
        "Observa también el volumen para mayor precisión.",
        "Ten en cuenta la tendencia global del mercado.",
        "Considera noticias recientes que puedan afectar al activo.",
        "Combina RSI con otras medias móviles para más eficacia.",
        "Analiza la volatilidad antes de comprar o vender."
      ];
      adviceText.textContent = randomAdvice[Math.floor(Math.random() * randomAdvice.length)];
    }

    modalClose.addEventListener('click', () => {
      modalOverlay.style.display = 'none';
    });

    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) {
        modalOverlay.style.display = 'none';
      }
    });

    verAnalisisBtn.addEventListener('click', () => {
      // Como la sección de análisis ha sido eliminada, deshabilitamos el botón
      // Alternativamente, podrías redirigir a otra sección o eliminar el botón
      // Por ahora, lo mantendremos como está
      // Podrías añadir una función que muestre más detalles si lo deseas
    });

    setAlertBtn.addEventListener('click', () => {
      const percentVal = parseFloat(priceAlertInput.value);
      if (!isNaN(percentVal) && percentVal > 0) {
        priceAlerts['globalPercentAlert'] = percentVal;
        localStorage.setItem('priceAlerts', JSON.stringify(priceAlerts));
        speakMessage(`Has establecido la alerta de ganancia en ${percentVal} porciento.`);
      }
    });

    setBuyPriceBtn.addEventListener('click', () => {
      if (currentModalCoinId && buyPriceInput.value) {
        const buyPrice = parseFloat(buyPriceInput.value);
        if (!isNaN(buyPrice) && buyPrice > 0) {
          buyPrices[currentModalCoinId] = buyPrice;
          localStorage.setItem('buyPrices', JSON.stringify(buyPrices));
          updateProfitLoss(currentModalCoinId, currentModalPrice);
          speakMessage(`Precio de compra establecido para ${currentModalCoinId} en ${buyPrice} dólares.`);
        }
      }
    });

    clearBuyPriceBtn.addEventListener('click', () => {
      if (currentModalCoinId) {
        delete buyPrices[currentModalCoinId];
        localStorage.setItem('buyPrices', JSON.stringify(buyPrices));
        buyPriceInput.value = "";
        profitLossText.textContent = "Ganancia/Perdida: 0%";
      }
    });

    btnFavoritos.addEventListener('click', () => {
      favoritesActive = true;
      applyFilters();
    });

    btnVerTodos.addEventListener('click', () => {
      favoritesActive = false;
      resetFilters();
    });

    updateChartBtn.addEventListener('click', async () => {
      await fetchCryptoData(true);
      if (currentModalCoinId && currentModalCoinName && currentModalPrice && currentModalSymbol) {
        await loadModalData(currentModalCoinId, currentModalCoinName, currentModalPrice, currentModalSymbol);
      }
    });

    coinFilter.addEventListener('change', () => {
      applyFilters();
    });

    rsiFilter.addEventListener('change', () => {
      applyFilters();
    });

    // Primer fetch
    fetchCryptoData(false);

    // Timer
    function startUpdateTimer() {
      if (updateTimer) {
        clearInterval(updateTimer);
      }
      updateTimer = setInterval(async () => {
        await fetchCryptoData(true);
      }, updateInterval * 1000);
    }
    startUpdateTimer();

    // Funciones extra
    function calculateSMA(data, length) {
      const sma = [];
      for (let i = 0; i < data.length; i++) {
        if (i < length - 1) {
          sma.push(null);
        } else {
          const slice = data.slice(i - length + 1, i + 1);
          const sum = slice.reduce((a, b) => a + b, 0);
          sma.push(sum / length);
        }
      }
      return sma;
    }

    function generateAIPrediction(closePrices) {
      const predictions = [];
      const lastPrice = closePrices[closePrices.length - 1];
      for (let i = 1; i <= 10; i++) {
        const factor = 1 + (Math.random() - 0.5) * 0.02;
        predictions.push(lastPrice * factor);
      }
      return predictions;
    }

    function applyFilters() {
      const selectedCoin = coinFilter.value;
      const selectedRSI = rsiFilter.value;

      const cards = document.querySelectorAll('.crypto-card');
      cards.forEach(card => {
        let display = true;

        // Filtro de Favoritos
        if (favoritesActive) {
          const coinId = card.getAttribute('data-coin-id');
          if (!favorites.includes(coinId)) {
            display = false;
          }
        }

        // Filtro de Criptomoneda
        if (selectedCoin !== 'all') {
          const coinId = card.getAttribute('data-coin-id');
          if (coinId !== selectedCoin) {
            display = false;
          }
        }

        // Filtro de RSI
        if (selectedRSI !== 'all') {
          const rsiState = card.getAttribute('data-rsi-state');
          if (selectedRSI !== rsiState) {
            display = false;
          }
        }

        card.style.display = display ? 'block' : 'none';
      });

      // Reordenar después de aplicar filtros
      reorderCards();
    }

    function resetFilters() {
      coinFilter.value = 'all';
      rsiFilter.value = 'all';
      cryptoGrid.querySelectorAll('.crypto-card').forEach(card => {
        card.style.display = 'block';
      });
      reorderCards();
    }
  </script>
</body>
</html>
