<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Monitor Criptomonedas - RSI + PnL + Voz + Favoritas Primero</title>
  <style>
    /* === Estilos Generales === */
    body.dark {
      background-color: #0a0e17;
      color: #ffffff;
    }
    body.light {
      background-color: #f0f0f0;
      color: #000000;
    }
    body {
      font-family: 'Roboto', sans-serif;
      margin: 0;
      padding: 20px;
      transition: background-color 0.3s, color 0.3s;
    }
    h1 {
      text-align: center;
      color: #00ffcc;
      font-size: 2.5em;
      margin-bottom: 5px;
    }
    h3 {
      text-align: center;
      color: #7a8599;
      margin-top: -10px;
      font-size: 0.9em;
      font-weight: normal;
    }
    #indicatorExplanation {
      max-width: 800px;
      margin: 10px auto 20px auto;
      background-color: #1a2332;
      border-radius: 10px;
      padding: 15px;
      color: #ccc;
      font-size: 0.9em;
    }
    body.light #indicatorExplanation {
      background-color: #eaeaea;
      color: #333;
    }
    #indicatorExplanation p {
      margin: 5px 0;
      line-height: 1.3em;
    }
    #lastUpdate {
      text-align: center;
      margin-top: 5px;
      font-style: italic;
      color: #7a8599;
      margin-bottom: 20px;
    }
    #filtersContainer {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    #coinFilterContainer,
    #rsiFilterContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #1a2332;
      border-radius: 15px;
      padding: 10px;
    }
    body.light #coinFilterContainer,
    body.light #rsiFilterContainer {
      background-color: #eaeaea;
      color: #000000;
    }
    label {
      margin-bottom: 5px;
      font-weight: bold;
    }
    select {
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: transparent;
      color: inherit;
      min-width: 150px;
      /* Asegurar que las opciones sean visibles */
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      cursor: pointer;
    }
    /* Estilos para las opciones del select */
    #modalTimeFrameFilter option {
      background-color: #1a2332;
      color: #ffffff;
    }
    body.light #modalTimeFrameFilter option {
      background-color: #eaeaea;
      color: #000000;
    }

    /* === Eliminado el timeFrameContainer de la página principal === */

    #intervalContainer {
      text-align: center;
      margin-top: 10px;
      margin-bottom: 20px;
    }
    #intervalContainer label {
      margin-right: 5px;
    }
    #updateIntervalInput {
      width: 60px;
      padding: 5px;
      border-radius: 5px;
      border: none;
    }
    #setIntervalBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #00ffcc;
      color: #0a0e17;
      cursor: pointer;
    }

    #cryptoGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
    }
    .crypto-card {
      background-color: #1a2332;
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
      cursor: pointer;
      position: relative;
    }
    body.light .crypto-card {
      background-color: #ffffff;
      color: #000000;
    }
    .crypto-card:hover {
      transform: translateY(-5px);
    }
    .crypto-card:hover::after {
      content: "Clic para ver gráfico";
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #00ffcc;
      color: #0a0e17;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      white-space: nowrap;
    }
    .crypto-logo {
      width: 60px;
      height: 60px;
      margin-bottom: 15px;
    }
    .crypto-name {
      font-size: 1.2em;
      font-weight: bold;
      margin-bottom: 10px;
      word-break: break-word;
    }
    .crypto-price {
      font-size: 1.1em;
      margin-bottom: 15px;
    }
    .flag {
      display: inline-block;
      padding: 8px 15px;
      border-radius: 20px;
      font-weight: bold;
      text-transform: uppercase;
      font-size: 0.9em;
      white-space: nowrap;
    }
    .green-flag {
      background-color: #4CAF50;
      color: white;
    }
    .red-flag {
      background-color: #F44336;
      color: white;
    }
    .neutral-flag {
      background-color: #FF9800;
      color: white;
    }
    .mini-chart-container {
      margin-top: 15px;
      position: relative;
      height: 80px;
    }
    canvas.mini-chart {
      width: 100%;
      height: 100%;
    }
    .no-chart-text {
      margin-top: 15px;
      font-size: 0.8em;
      color: #7a8599;
    }
    .favorite-icon {
      position: absolute;
      top: 10px;
      right: 10px;
      cursor: pointer;
      font-size: 1.2em;
      color: #ffc107;
    }
    #error {
      text-align: center;
      color: #F44336;
      font-size: 1.2em;
      margin-top: 50px;
      display: none;
    }
    #modalOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      padding: 0;
      overflow: hidden;
    }
    #modalContent {
      background: #1a2332;
      border-radius: 15px;
      width: 95vw;
      height: 95vh;
      position: relative;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding: 20px;
      transition: width 0.3s, height 0.3s;
    }
    body.light #modalContent {
      background: #f0f0f0;
      color: #000000;
    }
    #modalClose {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #00ffcc;
      color: #0a0e17;
      border: none;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
      padding: 10px;
      border-radius: 5px;
    }
    #chartContainer {
      width: 100%;
      min-height: 300px;
      margin-bottom: 20px;
      position: relative;
      transition: width 0.3s, height 0.3s; 
    }
    /* Clase expandida para móviles */
    #modalOverlay.expanded-view #modalContent {
      width: 100vw;
      height: 100vh;
      border-radius: 0;
      flex-direction: column;
    }
    #modalOverlay.expanded-view #chartContainer {
      height: 80vh;
      flex-grow: 1;
    }
    /* Mover .expanded-chart fuera de la media query */
    #chartContainer.expanded-chart {
      width: 100%;
      height: 80vh; /* Ajustar según sea necesario */
    }
    #cryptoChart {
      width: 100%;
      height: 100%;
    }
    .modal-footer {
      font-size: 0.9em;
      color: #7a8599;
      text-align: center;
      word-break: break-all;
      margin-top: 20px;
    }
    body.light .modal-footer {
      color: #333333;
    }
    .modal-info {
      text-align: center;
      margin-bottom: 10px;
    }
    .modal-info p {
      margin: 5px 0;
    }
    .modal-explanation {
      font-size: 0.9em;
      margin-top: 15px;
      background-color: #0a0e17;
      padding: 10px;
      border-radius: 10px;
    }
    body.light .modal-explanation {
      background-color: #ddd;
      color: #000;
    }
    .modal-explanation h4 {
      margin-top: 10px;
      margin-bottom: 5px;
    }
    #priceAlertContainer {
      margin: 10px 0;
      text-align: center;
    }
    #percentAlertLabel {
      display: inline-block;
      margin-right: 5px;
    }
    #priceAlertInput {
      width: 60px;
      padding: 5px;
      border-radius: 5px;
      border: none;
    }
    #setAlertBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #00ffcc;
      color: #0a0e17;
      cursor: pointer;
    }
    #buyPriceContainer {
      margin: 10px 0;
      text-align: center;
    }
    #buyPriceInput {
      width: 100px;
      padding: 5px;
      border-radius: 5px;
      border: none;
    }
    #setBuyPriceBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #00ffcc;
      color: #0a0e17;
      cursor: pointer;
    }
    #clearBuyPriceBtn {
      padding: 5px 10px;
      margin-left: 5px;
      border-radius: 5px;
      border: none;
      background: #F44336;
      color: white;
      cursor: pointer;
    }
    #profitLossContainer {
      margin: 10px 0;
      text-align: center;
    }
    #profitLossText {
      margin: 5px;
      font-weight: bold;
    }
    .green-arrow {
      color: #00ff00;
      font-weight: bold;
    }
    .red-arrow {
      color: #ff4444;
      font-weight: bold;
    }
    #themeToggle {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background-color: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 0.8em;
      z-index: 2000;
    }
    #favoritesBar {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 5px;
      z-index: 1000;
    }
    #btnFavoritos, #btnVerTodos {
      background-color: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 8px;
      cursor: pointer;
      border-radius: 5px;
      font-size: 0.8em;
    }
    #updateChartBtn {
      background: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px auto 5px auto;
      display: block;
      font-size: 0.9em;
    }
    #lastUpdateModal {
      text-align: center;
      font-style: italic;
      color: #7a8599;
      margin-top: 5px;
      margin-bottom: 10px;
    }
    #verAnalisisBtn {
      background: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px auto 0 auto;
      display: block;
      font-size: 0.9em;
    }
    #volverBtn {
      background: #00ffcc;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px auto 0 auto;
      display: none; /* Inicialmente oculto */
      font-size: 0.9em;
    }
    #silenciarAlertasBtn {
      background: #FF9800;
      color: #0a0e17;
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      cursor: pointer;
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 2100;
    }

    /* === Barra de Progreso === */
    #progressOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 4000;
      flex-direction: column;
      color: #ffffff;
      font-size: 1.2em;
      flex-wrap: wrap;
    }
    #progressBarContainer {
      width: 80%;
      background-color: #ddd;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 20px;
    }
    #progressBar {
      width: 0%;
      height: 30px;
      background-color: #00ffcc;
      transition: width 0.3s;
    }
    @media (max-width: 768px) {
      #modalContent {
        width: 98vw;
        height: 98vh;
      }
      #progressBarContainer {
        width: 90%;
      }
      /* Ya movimos .expanded-chart fuera de la media query */
    }

    /* === Estilos para Vista Expandida en el Modal === */
    /* Ya definidos arriba */

    /* === Nuevos Estilos para el Selector de Marco Temporal en el Modal === */
    #modalTimeFrameContainer {
      text-align: center;
      margin-bottom: 20px;
    }
    #modalTimeFrameContainer label {
      margin-right: 5px;
      font-weight: bold;
    }
    #modalTimeFrameFilter {
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #00ffcc;
      background-color: transparent;
      color: inherit;
      min-width: 150px;
      /* Asegurar que las opciones sean visibles */
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      cursor: pointer;
    }
    /* Estilos para las opciones del select */
    #modalTimeFrameFilter option {
      background-color: #1a2332;
      color: #ffffff;
    }
    body.light #modalTimeFrameFilter option {
      background-color: #eaeaea;
      color: #000000;
    }
  </style>
</head>
<body class="dark">
  <h1>Monitor Criptomonedas</h1>
  <h3>by Pablo Bascoy</h3>

  <!-- Barra de progreso -->
  <div id="progressOverlay">
    <div id="progressMessage">Cargando criptomonedas...</div>
    <div id="progressBarContainer">
      <div id="progressBar"></div>
    </div>
    <div id="progressText">0%</div>
  </div>

  <!-- Explicación de RSI -->
  <div id="indicatorExplanation">
    <p><strong>¿Qué es el RSI (Relative Strength Index)?</strong></p>
    <p>El RSI mide la fortaleza o debilidad de un activo según sus últimos movimientos de precio, entre 0 y 100.</p>
    <ul>
      <li>RSI &gt; 70: Señal de venta.</li>
      <li>RSI &lt; 30: Señal de compra.</li>
      <li>RSI 30-70: Fase neutra.</li>
    </ul>
    <p>Las criptomonedas marcadas como favoritas aparecerán primero cada vez que se actualice (automático o manual).  
    Puedes actualizar manualmente o cada cierto número de segundos. El % de ganancia/pérdida se recalcula según tu precio de compra.</p>
  </div>

  <p id="lastUpdate">Última actualización: (sin datos)</p>

  <div id="intervalContainer">
    <label>Actualización (segundos):
      <input type="number" id="updateIntervalInput" placeholder="30">
    </label>
    <button id="setIntervalBtn">Set Interval</button>
  </div>

  <div id="filtersContainer">
    <div id="coinFilterContainer">
      <label for="coinFilter">Criptomoneda</label>
      <select id="coinFilter">
          <option value="all">Todas</option>
      </select>
    </div>
    <div id="rsiFilterContainer">
      <label for="rsiFilter">Estado RSI</label>
      <select id="rsiFilter">
          <option value="all">Todas</option>
          <option value="comprar">Comprar</option>
          <option value="vender">Vender</option>
          <option value="esperar">Esperar</option>
          <option value="neutral">Neutral</option>
      </select>
    </div>
    <!-- Eliminado el timeFrameContainer de la página principal -->
  </div>

  <div id="error">No se pudo acceder a los datos en tiempo real. Por favor, intente más tarde.</div>
  <div id="cryptoGrid"></div>

  <!-- Modal -->
  <div id="modalOverlay">
    <div id="modalContent">
      <button id="modalClose">Regresar</button>
      <h2 id="modalTitle"></h2>
      <!-- Botón Actualizar que ahora solo actualiza la cripto del modal -->
      <button id="updateChartBtn">Actualizar</button>
      <!-- Selector de Marco Temporal en el Modal -->
      <div id="modalTimeFrameContainer">
        <label for="modalTimeFrameFilter">Marco Temporal</label>
        <select id="modalTimeFrameFilter">
            <option value="5m">5 Minutos</option>
            <option value="15m">15 Minutos</option>
            <option value="1h">1 Hora</option>
            <option value="1d">Por Día</option>
            <option value="1w">Por Semana</option>
            <option value="1M">Por Mes</option>
            <option value="6M">Últimos 6 Meses</option>
            <option value="1Y">Último Año</option>
        </select>
      </div>
      <p id="lastUpdateModal"></p>
      <div class="modal-info" id="modalInfo"></div>
      <div id="chartContainer">
        <canvas id="cryptoChart"></canvas>
      </div>
      <!-- Botón para expandir el gráfico en móvil -->
      <button id="verAnalisisBtn">Ver Análisis</button>
      <!-- Botón para volver desde la vista expandida -->
      <button id="volverBtn">Volver</button>

      <div id="priceAlertContainer">
        <label id="percentAlertLabel">% de ganancia para alerta:
          <input type="number" id="priceAlertInput" placeholder="5">
        </label>
        <button id="setAlertBtn">Set Alert</button>
      </div>

      <div id="buyPriceContainer">
        <label>Precio de Compra: $<input type="number" id="buyPriceInput" placeholder="0.00"></label>
        <button id="setBuyPriceBtn">Colocar precio de compra</button>
        <button id="clearBuyPriceBtn">Borrar precio de compra</button>
      </div>
      <div id="profitLossContainer">
        <p id="profitLossText">Ganancia/Perdida: 0%</p>
      </div>

      <div class="modal-explanation">
        <h4>Explicación de los Indicadores:</h4>
        <p><span style="color:#00ffcc;font-weight:bold;">Línea principal (cyan):</span> Representa el <strong>precio histórico</strong> de la criptomoneda.</p>
        <p><span style="color:#4CAF50;font-weight:bold;">Línea de tendencia (verde/punteada):</span> Indica la <strong>tendencia actual</strong> del precio.</p>
        <p><span style="color:#FFD700;font-weight:bold;">SMA (7) (amarillo):</span> <strong>Media Móvil Simple de 7 periodos</strong>.</p>
        <p><span style="color:#FF8C00;font-weight:bold;">SMA (30) (naranja):</span> <strong>Media Móvil Simple de 30 periodos</strong>.</p>
        <p><span style="color:#00BFFF;font-weight:bold;">Volumen (azul):</span> <strong>cantidad de operaciones</strong> en cada periodo.</p>
        <p><span style="color:#EE82EE;font-weight:bold;">Línea IA (violeta):</span> <strong>predicción IA</strong> basada en patrones históricos.</p>
        <h4>Consejo:</h4>
        <p id="adviceText">(Se llenará con consejos aleatorios)</p>
      </div>

      <div class="modal-footer">
        <span id="dataSource"></span>
      </div>
    </div>
  </div>

  <button id="themeToggle">Tema</button>
  <div id="favoritesBar">
    <button id="btnFavoritos">Favoritos</button>
    <button id="btnVerTodos">Ver Todos</button>
  </div>

  <button id="silenciarAlertasBtn">Silenciar Alertas</button>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Chart.js Zoom Plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

  <script>
    let chartInstance = null;
    let cryptoData = [];
    let favorites = JSON.parse(localStorage.getItem('favorites')) || [];
    let priceAlerts = JSON.parse(localStorage.getItem('priceAlerts')) || {};
    let buyPrices = JSON.parse(localStorage.getItem('buyPrices')) || {};
    let currentModalCoinId = null;
    let currentModalCoinName = null;
    let currentModalPrice = null;
    let currentModalSymbol = null;
    let silenciarAlertas = false;
    let updateTimer = null;
    let favoritesActive = false; // Flag para controlar el filtro de favoritos
    let updateInterval = parseInt(localStorage.getItem('updateInterval')) || 30; // Intervalo por defecto

    // Referencias a elementos del DOM
    const body = document.body;
    const themeToggle = document.getElementById('themeToggle');
    const silenciarAlertasBtn = document.getElementById('silenciarAlertasBtn');
    const lastUpdateElement = document.getElementById('lastUpdate');
    const errorElement = document.getElementById('error');
    const cryptoGrid = document.getElementById('cryptoGrid');
    const coinFilter = document.getElementById('coinFilter');
    const rsiFilter = document.getElementById('rsiFilter');
    const modalOverlay = document.getElementById('modalOverlay');
    const modalClose = document.getElementById('modalClose');
    const modalTitle = document.getElementById('modalTitle');
    const dataSource = document.getElementById('dataSource');
    const modalInfo = document.getElementById('modalInfo');
    const adviceText = document.getElementById('adviceText');
    const verAnalisisBtn = document.getElementById('verAnalisisBtn');
    const volverBtn = document.getElementById('volverBtn'); // Botón "Volver"
    const lastUpdateModal = document.getElementById('lastUpdateModal');
    const priceAlertInput = document.getElementById('priceAlertInput');
    const setAlertBtn = document.getElementById('setAlertBtn');
    const buyPriceInput = document.getElementById('buyPriceInput');
    const setBuyPriceBtn = document.getElementById('setBuyPriceBtn');
    const clearBuyPriceBtn = document.getElementById('clearBuyPriceBtn');
    const profitLossText = document.getElementById('profitLossText');
    const btnFavoritos = document.getElementById('btnFavoritos');
    const btnVerTodos = document.getElementById('btnVerTodos');
    const updateChartBtn = document.getElementById('updateChartBtn');
    const updateIntervalInputElem = document.getElementById('updateIntervalInput');
    const setIntervalBtnElem = document.getElementById('setIntervalBtn');
    const modalTimeFrameFilter = document.getElementById('modalTimeFrameFilter'); // Nuevo

    // Barra de progreso
    const progressOverlay = document.getElementById('progressOverlay');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const progressMessage = document.getElementById('progressMessage');

    // === 1) Manejo de tema (dark/light) ===
    const savedTheme = localStorage.getItem('theme') || 'dark';
    body.className = savedTheme;
    themeToggle.addEventListener('click', () => {
      body.className = (body.className === 'dark') ? 'light' : 'dark';
      localStorage.setItem('theme', body.className);
      if (chartInstance) {
        // Ajustar colores del gráfico
        chartInstance.options.scales.y.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y1.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.x.ticks.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.scales.y1.title.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.options.plugins.legend.labels.color = body.className === 'dark' ? '#ffffff' : '#000000';
        chartInstance.update();
      }
    });

    // === 2) Botón silenciar alertas (voz) ===
    silenciarAlertasBtn.addEventListener('click', () => {
      silenciarAlertas = !silenciarAlertas;
      silenciarAlertasBtn.textContent = silenciarAlertas ? "Activar Alertas" : "Silenciar Alertas";
    });

    // === 3) Intervalo de actualización (global) ===
    updateIntervalInputElem.value = updateInterval;
    setIntervalBtnElem.addEventListener('click', () => {
      const newVal = parseInt(updateIntervalInputElem.value);
      if (!isNaN(newVal) && newVal > 0) {
        updateInterval = newVal;
        localStorage.setItem('updateInterval', updateInterval);
        speakMessage(`Intervalo de actualización configurado a ${updateInterval} segundos.`);
        if (updateTimer) clearInterval(updateTimer);
        startUpdateTimer();
      }
    });

    // === 4) RSI y recomendación ===
    function calculateRSI(closePrices, period = 14) {
      if (closePrices.length < period) return null;
      let gains = 0;
      let losses = 0;
      for (let i = 1; i < period; i++) {
        const diff = closePrices[i] - closePrices[i - 1];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      let avgGain = gains / (period - 1);
      let avgLoss = losses / (period - 1);

      let rsiArray = [null];
      for (let i = period; i < closePrices.length; i++) {
        const diff = closePrices[i] - closePrices[i - 1];
        const gain = diff > 0 ? diff : 0;
        const loss = diff < 0 ? -diff : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;

        if (avgLoss === 0) {
          rsiArray.push(100);
        } else {
          const rs = avgGain / avgLoss;
          rsiArray.push(100 - (100 / (1 + rs)));
        }
      }
      return rsiArray[rsiArray.length - 1];
    }

    function getRecommendationFromRSI(rsiValue) {
      if (rsiValue === null) {
        return { flag: 'neutral-flag', text: 'Neutral (Sin RSI)', state: 'neutral' };
      }
      if (rsiValue > 70) {
        return { flag: 'red-flag', text: 'Vender (RSI>70)', state: 'vender' };
      } else if (rsiValue < 30) {
        return { flag: 'green-flag', text: 'Comprar (RSI<30)', state: 'comprar' };
      } else if (rsiValue >= 30 && rsiValue <= 70) {
        return { flag: 'neutral-flag', text: 'Esperar (RSI 30-70)', state: 'esperar' };
      } else {
        return { flag: 'neutral-flag', text: 'Neutral (Sin RSI)', state: 'neutral' };
      }
    }

    // === 5) Voz (alertas) ===
    function speakMessage(text) {
      if (silenciarAlertas) return;
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'es-ES';
        utterance.rate = 1;
        utterance.pitch = 1;
        speechSynthesis.speak(utterance);
      }
    }

    // === 6) Creación de tarjetas (cards) para cada cripto en la pantalla principal ===
    function createCryptoCard(crypto, index, rsiRecommendation) {
      const card = document.createElement('div');
      card.className = 'crypto-card';
      card.setAttribute('data-coin-id', crypto.id);
      card.setAttribute('data-current-price', crypto.current_price);
      card.setAttribute('data-rsi-state', rsiRecommendation.state);

      const isFav = favorites.includes(crypto.id);
      const star = isFav ? '★' : '☆';

      card.innerHTML = `
        <div class="favorite-icon">${star}</div>
        <img src="${crypto.image}" alt="${crypto.name} logo" class="crypto-logo">
        <div class="crypto-name">${crypto.name}</div>
        <div class="crypto-price">$${crypto.current_price.toFixed(2)}</div>
        <div class="flag ${rsiRecommendation.flag}">${rsiRecommendation.text}</div>
        <div class="mini-chart-container">
          <canvas id="miniChart-${index}" class="mini-chart"></canvas>
        </div>
      `;

      // Favorito
      card.querySelector('.favorite-icon').addEventListener('click', (e) => {
        e.stopPropagation();
        toggleFavorite(crypto.id, card);
      });

      // Abrir modal (clic o touch)
      card.addEventListener('click', () => {
        openModal(crypto.id, crypto.name, crypto.current_price, crypto.symbol.toUpperCase() + 'USDT');
      });

      return card;
    }

    function toggleFavorite(coinId, card) {
      if (favorites.includes(coinId)) {
        favorites = favorites.filter(f => f !== coinId);
        card.querySelector('.favorite-icon').textContent = '☆';
      } else {
        favorites.push(coinId);
        card.querySelector('.favorite-icon').textContent = '★';
      }
      localStorage.setItem('favorites', JSON.stringify(favorites));
      reorderCards();
      if (favoritesActive) {
        applyFilters();
      }
    }

    function reorderCards() {
      const cards = Array.from(document.querySelectorAll('.crypto-card'));
      const favCards = [];
      const otherCards = [];

      cards.forEach(card => {
        const coinId = card.getAttribute('data-coin-id');
        if (favorites.includes(coinId)) {
          favCards.push(card);
        } else {
          otherCards.push(card);
        }
      });

      cryptoGrid.innerHTML = '';
      favCards.forEach(c => cryptoGrid.appendChild(c));
      otherCards.forEach(c => cryptoGrid.appendChild(c));
    }

    // === 7) Carga de minigráfico (Binance) ===
    async function loadMiniChart(binanceSymbol, index) {
      try {
        // Utilizar un marco temporal fijo para mini gráficos, por ejemplo '5m'
        const miniTimeFrame = '5m';
        const endpoint = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=${miniTimeFrame}&limit=30`;
        const res = await fetch(endpoint, {cache:'no-store'});
        if (!res.ok) return false;
        const klineData = await res.json();
        if (!Array.isArray(klineData) || klineData.length === 0) return false;

        const closePrices = klineData.map(c => parseFloat(c[4]));
        const labels = klineData.map(c => {
          const date = new Date(c[0]);
          return `${date.getDate()}/${(date.getMonth()+1)} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
        });

        const miniCtx = document.getElementById(`miniChart-${index}`);
        if (!miniCtx) return false;
        const miniChartCtx = miniCtx.getContext('2d');
        new Chart(miniChartCtx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              data: closePrices,
              borderColor: '#00ffcc',
              backgroundColor: 'rgba(0,255,204,0.1)',
              tension: 0.3,
              fill: true,
              pointRadius: 0
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { display: false },
              y: { display: false }
            },
            plugins: {
              legend: { display: false }
            }
          }
        });
        return true;
      } catch (e) {
        return false;
      }
    }

    // === 8) PnL (Ganancia / Pérdida) en el modal ===
    function updateProfitLoss(coinId, currentPrice) {
      const buyVal = parseFloat(buyPrices[coinId] || 0);
      if (!isNaN(buyVal) && buyVal > 0) {
        const pnl = ((currentPrice - buyVal) / buyVal) * 100;
        let arrow = '';
        if (pnl > 0) {
          arrow = '<span class="green-arrow">▲</span>';
        } else if (pnl < 0) {
          arrow = '<span class="red-arrow">▼</span>';
        }
        profitLossText.innerHTML = `Ganancia/Perdida: ${pnl.toFixed(2)}% ${arrow}`;
      } else {
        profitLossText.textContent = `Ganancia/Perdida: 0%`;
      }
    }

    // === 9) Funciones para cargar TODAS las criptos o SOLO las favoritas ===
    async function fetchCryptoData(forceUpdate = false) {
      try {
        progressOverlay.style.display = 'flex';
        cryptoGrid.innerHTML = '';
        coinFilter.innerHTML = '<option value="all">Todas</option>';
        rsiFilter.value = 'all'; 
        btnFavoritos.disabled = true;
        btnVerTodos.disabled = true;
        coinFilter.disabled = true;
        rsiFilter.disabled = true;

        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=50&page=1&sparkline=false`;
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error("No se obtuvieron datos de CoinGecko.");
        }
        cryptoData = data;

        const totalCryptos = data.length;
        let loadedCryptos = 0;

        for (let coin of data) {
          await createCardWithRSI(coin, loadedCryptos, totalCryptos);
          loadedCryptos++;
          const progressPercentage = Math.round((loadedCryptos / totalCryptos) * 100);
          progressBar.style.width = `${progressPercentage}%`;
          progressText.textContent = `${progressPercentage}%`;
          progressMessage.textContent = `Cargando ${loadedCryptos} de ${totalCryptos} criptomonedas...`;
        }

        reorderCards();
        lastUpdateElement.textContent = `Última actualización: ${new Date().toLocaleString()}`;
        applyFilters();

        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      } catch (error) {
        console.error('Error al obtener datos:', error);
        errorElement.style.display = 'block';
        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      }
    }

    // Carga SOLO favoritas
    async function fetchFavoritesData() {
      try {
        progressOverlay.style.display = 'flex';
        cryptoGrid.innerHTML = '';
        coinFilter.innerHTML = '<option value="all">Todas</option>';
        rsiFilter.value = 'all'; 
        btnFavoritos.disabled = true;
        btnVerTodos.disabled = true;
        coinFilter.disabled = true;
        rsiFilter.disabled = true;

        if (favorites.length === 0) {
          // No hay favoritas, salimos
          progressOverlay.style.display = 'none';
          btnFavoritos.disabled = false;
          btnVerTodos.disabled = false;
          coinFilter.disabled = false;
          rsiFilter.disabled = false;
          return;
        }

        const favoritesIds = favorites.join('%2C'); 
        // Por ejemplo: "bitcoin%2Cethereum" en la query
        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${favoritesIds}&order=market_cap_desc&per_page=50&page=1&sparkline=false`;
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error("No se obtuvieron datos de las favoritas.");
        }
        cryptoData = data;

        const totalCryptos = data.length;
        let loadedCryptos = 0;

        for (let coin of data) {
          await createCardWithRSI(coin, loadedCryptos, totalCryptos);
          loadedCryptos++;
          const progressPercentage = Math.round((loadedCryptos / totalCryptos) * 100);
          progressBar.style.width = `${progressPercentage}%`;
          progressText.textContent = `${progressPercentage}%`;
          progressMessage.textContent = `Cargando favoritas (${loadedCryptos}/${totalCryptos})...`;
        }

        reorderCards();
        lastUpdateElement.textContent = `Última actualización: ${new Date().toLocaleString()}`;
        applyFilters();

        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      } catch (error) {
        console.error('Error al cargar favoritas:', error);
        progressOverlay.style.display = 'none';
        btnFavoritos.disabled = false;
        btnVerTodos.disabled = false;
        coinFilter.disabled = false;
        rsiFilter.disabled = false;
      }
    }

    // === 10) Crear card con RSI (para uso en fetchCryptoData y fetchFavoritesData) ===
    async function createCardWithRSI(coin, loadedCryptos, totalCryptos) {
      const binanceSymbol = (coin.symbol.toUpperCase() + 'USDT');
      let rsiValue = null;
      try {
        const res = await fetch(`https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=5m&limit=30`, { cache: 'no-store' }); // Usando '5m' para mini gráficos
        if (res.ok) {
          const klineData = await res.json();
          const closePrices = klineData.map(c => parseFloat(c[4]));
          if (closePrices.length > 0) {
            rsiValue = calculateRSI(closePrices, 14);
          }
        }
      } catch (err) {
        // error silencioso
      }
      const rsiRec = getRecommendationFromRSI(rsiValue);

      if (!silenciarAlertas && favorites.includes(coin.id) && rsiValue !== null) {
        const percentAlert = parseFloat(priceAlerts['globalPercentAlert'] || 5);
        if (rsiValue >= 70) {
          const buyVal = parseFloat(buyPrices[coin.id] || 0);
          if (buyVal > 0) {
            const pnl = ((coin.current_price - buyVal) / buyVal) * 100;
            if (pnl >= percentAlert) {
              speakMessage(`Se sugiere vender ${coin.name}. Ganancia de ${pnl.toFixed(2)} porciento, RSI: ${rsiValue.toFixed(2)}`);
            }
          }
        } else if (rsiValue < 30) {
          const buyVal = parseFloat(buyPrices[coin.id] || 0);
          if (buyVal === 0) {
            speakMessage(`Se sugiere comprar ${coin.name}. RSI: ${rsiValue.toFixed(2)}. Sin precio de compra configurado.`);
          }
        }
      }

      const card = createCryptoCard(coin, loadedCryptos, rsiRec);
      cryptoGrid.appendChild(card);

      const opt = document.createElement('option');
      opt.value = coin.id;
      opt.textContent = coin.name;
      coinFilter.appendChild(opt);

      const loaded = await loadMiniChart(binanceSymbol, loadedCryptos);
      if (!loaded) {
        card.querySelector('.mini-chart-container').innerHTML = `<p class="no-chart-text">Sin datos de gráfico</p>`;
      }
    }

    // === 11) Carga y Actualización de UNA sola cripto (para el modal) ===
    // Esto se usará cuando en el modal se presione "Actualizar", para NO recargar las 50.
    async function fetchSingleCoinData(coinId) {
      try {
        // Llamada a la API para 1 sola criptomoneda
        const endpoint = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coinId}&order=market_cap_desc&per_page=1&page=1&sparkline=false`;
        const response = await fetch(endpoint, { cache: 'no-store' });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          throw new Error(`No se obtuvieron datos para ${coinId}.`);
        }
        const coin = data[0];
        currentModalCoinId = coin.id;
        currentModalCoinName = coin.name;
        currentModalPrice = coin.current_price;
        currentModalSymbol = coin.symbol.toUpperCase() + 'USDT';

        // Volvemos a cargar el modal con loadModalData
        await loadModalData(currentModalCoinId, currentModalCoinName, currentModalPrice, currentModalSymbol);
      } catch (error) {
        console.error('Error al obtener datos de una sola criptomoneda:', error);
      }
    }

    // === 12) Apertura del modal ===
    async function openModal(coinId, coinName, currentPrice, binanceSymbol) {
      currentModalCoinId = coinId;
      currentModalCoinName = coinName;
      currentModalPrice = currentPrice;
      currentModalSymbol = binanceSymbol;
      // Inicializar el marco temporal del modal a '5m'
      modalTimeFrameFilter.value = '5m';
      await loadModalData(coinId, coinName, currentPrice, binanceSymbol);
    }

    // === 13) Carga del modal (gráfico principal) ===
    async function loadModalData(coinId, coinName, currentPrice, binanceSymbol) {
      try {
        const modalTimeFrame = modalTimeFrameFilter.value; // Obtener el marco temporal seleccionado en el modal
        // Verificar si el intervalo es soportado por Binance
        const supportedIntervals = ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '8h', '12h', '1d', '3d', '1w', '1M'];
        if (!supportedIntervals.includes(modalTimeFrame)) {
          throw new Error(`Intervalo de tiempo "${modalTimeFrame}" no soportado por Binance.`);
        }

        const endpoint = `https://api.binance.com/api/v3/klines?symbol=${binanceSymbol}&interval=${modalTimeFrame}&limit=100`;
        const response = await fetch(endpoint, {cache:'no-store'});
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const klineData = await response.json();
        if (!Array.isArray(klineData) || klineData.length === 0) {
          throw new Error(`Sin datos para ${coinName}.`);
        }

        const closePrices = klineData.map(c => parseFloat(c[4]));
        const volumes = klineData.map(c => parseFloat(c[5]));
        const labels = klineData.map(c => {
          const date = new Date(c[0]);
          const year = String(date.getFullYear()).slice(-2); // two-digit year
          return `${date.getDate()}/${(date.getMonth()+1)}/${year} ${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`;
        });

        // RSI
        const rsiValue = calculateRSI(closePrices, 14);
        const rsiRec = getRecommendationFromRSI(rsiValue);

        modalTitle.textContent = `${coinName} - Tendencia: ${rsiRec.text}`;
        dataSource.textContent = endpoint;

        modalInfo.innerHTML = `
          <p>Precio Actual: $${currentPrice.toFixed(2)}</p>
          <p>RSI (14): ${rsiValue ? rsiValue.toFixed(2) : 'N/A'}</p>
        `;

        modalOverlay.style.display = 'flex';

        // Destruimos un chart anterior
        if (chartInstance) {
          chartInstance.destroy();
        }

        // IA line
        const aiPredictions = generateAIPrediction(closePrices);
        const aiLabels = [];
        for (let i = 1; i <= aiPredictions.length; i++) {
          aiLabels.push(`Futuro+${i}`);
        }

        // SMA
        const shortSMA = calculateSMA(closePrices, 7);
        const longSMA = calculateSMA(closePrices, 30);

        // Preparar los datos para el gráfico
        const aiLine = Array(closePrices.length).fill(null).concat(aiPredictions);

        setTimeout(() => {
          chartInstance = new Chart(document.getElementById('cryptoChart').getContext('2d'), {
            data: {
              labels: labels.concat(aiLabels),
              datasets: [
                {
                  type: 'line',
                  label: `${coinName} (USD)`,
                  data: closePrices.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#00ffcc',
                  backgroundColor: 'rgba(0,255,204,0.1)',
                  tension: 0.3,
                  fill: true,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: `Línea de tendencia (${rsiRec.text})`,
                  data: closePrices.map(() => closePrices[closePrices.length -1]).concat(Array(aiPredictions.length).fill(null)),
                  borderColor: (rsiRec.flag === 'green-flag') ? '#4CAF50' :
                              (rsiRec.flag === 'red-flag')   ? '#F44336' : '#FF9800',
                  borderDash: [5, 5],
                  pointRadius: 0,
                  fill: false,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: 'SMA (7)',
                  data: shortSMA.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#FFD700',
                  fill: false,
                  pointRadius: 0,
                  tension: 0.2,
                  yAxisID: 'y',
                },
                {
                  type: 'line',
                  label: 'SMA (30)',
                  data: longSMA.concat(Array(aiPredictions.length).fill(null)),
                  borderColor: '#FF8C00',
                  fill: false,
                  pointRadius: 0,
                  tension: 0.2,
                  yAxisID: 'y',
                },
                {
                  type: 'bar',
                  label: 'Volumen',
                  data: volumes.concat(Array(aiPredictions.length).fill(null)),
                  backgroundColor: 'rgba(0,191,255,0.3)',
                  borderColor: '#00BFFF',
                  borderWidth: 1,
                  yAxisID: 'y1'
                },
                {
                  type: 'line',
                  label: 'Línea IA (Predicción)',
                  data: aiLine,
                  borderColor: '#EE82EE',
                  borderDash: [2, 2],
                  pointRadius: 0,
                  fill: false,
                  tension: 0.2,
                  yAxisID: 'y',
                }
              ]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: {
                mode: 'index',
                intersect: false,
              },
              scales: {
                y: {
                  type: 'linear',
                  display: true,
                  position: 'left',
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Precio (USD)',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                y1: {
                  type: 'linear',
                  display: true,
                  position: 'right',
                  ticks: { color: body.className === 'dark' ? '#ffffff' : '#000000' },
                  title: {
                    display: true,
                    text: 'Volumen',
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  },
                  grid: {
                    drawOnChartArea: false,
                  },
                },
                x: {
                  ticks: { 
                    color: body.className === 'dark' ? '#ffffff' : '#000000',
                    callback: function(value, index, values) {
                      return this.getLabelForValue(value);
                    }
                  }
                }
              },
              plugins: {
                legend: {
                  labels: {
                    color: body.className === 'dark' ? '#ffffff' : '#000000'
                  }
                },
                tooltip: {
                  mode: 'index',
                  intersect: false,
                },
                zoom: { // Configuración del plugin de zoom
                  pan: {
                    enabled: true,
                    mode: 'xy',
                  },
                  zoom: {
                    wheel: {
                      enabled: true,
                    },
                    pinch: {
                      enabled: true
                    },
                    mode: 'xy',
                  }
                }
              },
            }
          });
          chartInstance.update();
        }, 100);

        fillAdviceAndComments();
        lastUpdateModal.textContent = `Última actualización: ${new Date().toLocaleString()}`;

        if (buyPrices[coinId]) {
          buyPriceInput.value = buyPrices[coinId];
        } else {
          buyPriceInput.value = "";
        }
        updateProfitLoss(coinId, currentPrice);
      } catch (error) {
        console.error('Error al mostrar modal con gráfico:', error);
        modalTitle.textContent = `${coinName} - Sin datos de gráfico`;
        modalInfo.innerHTML = `<p>No se pudieron obtener datos del gráfico. Intente más tarde.</p>`;
        adviceText.textContent = "No hay suficientes datos para dar un consejo.";
        dataSource.textContent = "";
        modalOverlay.style.display = 'flex';
        lastUpdateModal.textContent = "";
      }
    }

    function fillAdviceAndComments() {
      const randomAdvice = [
        "Observa también el volumen para mayor precisión.",
        "Ten en cuenta la tendencia global del mercado.",
        "Considera noticias recientes que puedan afectar al activo.",
        "Combina RSI con otras medias móviles para más eficacia.",
        "Analiza la volatilidad antes de comprar o vender."
      ];
      adviceText.textContent = randomAdvice[Math.floor(Math.random() * randomAdvice.length)];
    }

    // === 14) Cierre del modal ===
    modalClose.addEventListener('click', () => {
      cerrarModal();
    });

    modalOverlay.addEventListener('click', (e) => {
      if (e.target === modalOverlay) {
        cerrarModal();
      }
    });

    function cerrarModal() {
      modalOverlay.classList.remove('expanded-view'); // Remover clase de vista expandida si existe
      cerrarVistaExpandida();
      modalOverlay.style.display = 'none';
    }

    // === 15) Botón "Ver Análisis" (Expandir gráfico) ===
    verAnalisisBtn.addEventListener('click', () => {
      const isMobile = window.matchMedia("only screen and (max-width: 768px)").matches;
      if (isMobile) {
        // Expandir el modal a pantalla completa en vertical (aprovechar el espacio disponible)
        modalOverlay.classList.add('expanded-view');
        const chartContainer = document.getElementById('chartContainer');
        chartContainer.classList.add('expanded-chart');
        if (chartInstance) {
          chartInstance.resize();
          chartInstance.update();
        }

        // Mostrar botón "Volver" y ocultar "Ver Análisis"
        verAnalisisBtn.style.display = 'none';
        volverBtn.style.display = 'block';
      } else {
        // Para escritorio, podrías implementar otra funcionalidad si lo deseas
        alert("Esta funcionalidad está optimizada para dispositivos móviles.");
      }
    });

    // === 16) Botón "Volver" (Revertir expansión del gráfico) ===
    volverBtn.addEventListener('click', () => {
      cerrarVistaExpandida();
    });

    function cerrarVistaExpandida() {
      modalOverlay.classList.remove('expanded-view');
      const chartContainer = document.getElementById('chartContainer');
      chartContainer.classList.remove('expanded-chart');
      if (chartInstance) {
        chartInstance.resize();
        chartInstance.update();
      }

      // Mostrar botón "Ver Análisis" y ocultar "Volver"
      verAnalisisBtn.style.display = 'block';
      volverBtn.style.display = 'none';
    }

    // === 17) Botones de Alertas ===
    setAlertBtn.addEventListener('click', () => {
      const percentVal = parseFloat(priceAlertInput.value);
      if (!isNaN(percentVal) && percentVal > 0) {
        priceAlerts['globalPercentAlert'] = percentVal;
        localStorage.setItem('priceAlerts', JSON.stringify(priceAlerts));
        speakMessage(`Has establecido la alerta de ganancia en ${percentVal} porciento.`);
      }
    });

    setBuyPriceBtn.addEventListener('click', () => {
      if (currentModalCoinId && buyPriceInput.value) {
        const buyPrice = parseFloat(buyPriceInput.value);
        if (!isNaN(buyPrice) && buyPrice > 0) {
          buyPrices[currentModalCoinId] = buyPrice;
          localStorage.setItem('buyPrices', JSON.stringify(buyPrices));
          updateProfitLoss(currentModalCoinId, currentModalPrice);
          speakMessage(`Precio de compra establecido para ${currentModalCoinId} en ${buyPrice} dólares.`);
        }
      }
    });

    clearBuyPriceBtn.addEventListener('click', () => {
      if (currentModalCoinId) {
        delete buyPrices[currentModalCoinId];
        localStorage.setItem('buyPrices', JSON.stringify(buyPrices));
        buyPriceInput.value = "";
        profitLossText.textContent = "Ganancia/Perdida: 0%";
      }
    });

    // === 18) Botones de Favoritos y Ver Todos ===
    btnFavoritos.addEventListener('click', async () => {
      favoritesActive = true;
      await fetchFavoritesData();
    });

    btnVerTodos.addEventListener('click', async () => {
      favoritesActive = false;
      await fetchCryptoData(true);
    });

    // === 19) Botón "Actualizar" en el Modal ===
    updateChartBtn.addEventListener('click', async () => {
      // Llamamos a fetchSingleCoinData para actualizar solo esta cripto
      if (currentModalCoinId) {
        await fetchSingleCoinData(currentModalCoinId);
      }
    });

    // === 20) Selector de Marco Temporal en el Modal ===
    modalTimeFrameFilter.addEventListener('change', async () => {
      // Si el modal está abierto, actualizar su gráfico
      if (modalOverlay.style.display === 'flex' && currentModalCoinId) {
        await loadModalData(currentModalCoinId, currentModalCoinName, currentModalPrice, currentModalSymbol);
      }
    });

    // === 21) Función de Filtros ===
    function applyFilters() {
      const selectedCoin = coinFilter.value;
      const selectedRSI = rsiFilter.value;

      const cards = document.querySelectorAll('.crypto-card');
      cards.forEach(card => {
        let display = true;

        // Filtro de Favoritos
        if (favoritesActive) {
          const coinId = card.getAttribute('data-coin-id');
          if (!favorites.includes(coinId)) {
            display = false;
          }
        }

        // Filtro de Criptomoneda
        if (selectedCoin !== 'all') {
          const coinId = card.getAttribute('data-coin-id');
          if (coinId !== selectedCoin) {
            display = false;
          }
        }

        // Filtro de RSI
        if (selectedRSI !== 'all') {
          const rsiState = card.getAttribute('data-rsi-state');
          if (selectedRSI !== rsiState) {
            display = false;
          }
        }

        card.style.display = display ? 'block' : 'none';
      });

      // Reordenar después de aplicar filtros
      reorderCards();
    }

    function resetFilters() {
      coinFilter.value = 'all';
      rsiFilter.value = 'all';
      cryptoGrid.querySelectorAll('.crypto-card').forEach(card => {
        card.style.display = 'block';
      });
      reorderCards();
    }

    // === 22) Función para manejar la expansión del gráfico en móviles con un solo clic ===
    // Ya está implementada mediante los botones "Ver Análisis" y "Volver"

    // === 23) Función de Inicio ===
    async function initialize() {
      // Primer fetch según estado inicial (Ver Todos o Favoritos)
      if (favoritesActive) {
        await fetchFavoritesData();
      } else {
        await fetchCryptoData(false);
      }

      // Iniciar el timer de actualización
      startUpdateTimer();
    }

    // === 24) Timer de Actualización ===
    function startUpdateTimer() {
      if (updateTimer) {
        clearInterval(updateTimer);
      }
      updateTimer = setInterval(async () => {
        if (favoritesActive) {
          await fetchFavoritesData();
        } else {
          await fetchCryptoData(true);
        }
      }, updateInterval * 1000);
    }

    // === 25) Funciones Extra ===
    function calculateSMA(data, length) {
      const sma = [];
      for (let i = 0; i < data.length; i++) {
        if (i < length - 1) {
          sma.push(null);
        } else {
          const slice = data.slice(i - length + 1, i + 1);
          const sum = slice.reduce((a, b) => a + b, 0);
          sma.push(sum / length);
        }
      }
      return sma;
    }

    function generateAIPrediction(closePrices) {
      const predictions = [];
      const lastPrice = closePrices[closePrices.length - 1];
      for (let i = 1; i <= 10; i++) {
        const factor = 1 + (Math.random() - 0.5) * 0.02;
        predictions.push(lastPrice * factor);
      }
      return predictions;
    }

    // === 26) Carga Inicial ===
    initialize();

  </script>
</body>
</html>
